<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>25-Fall 留学申请记录</title>
    <url>/2024/08/24/25-Fall-Record/</url>
    <content><![CDATA[<p>别着急，还没开始写呢</p>
]]></content>
      <categories>
        <category>升学记录</category>
      </categories>
      <tags>
        <tag>留学</tag>
        <tag>上岸</tag>
      </tags>
  </entry>
  <entry>
    <title>算法期末总结</title>
    <url>/2024/08/24/Algorithm-Summary/</url>
    <content><![CDATA[<h1 id="算法期末复习"><a href="#算法期末复习" class="headerlink" title="算法期末复习"></a>算法期末复习</h1><hr>
<h2 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h2><p>对照着潘老师的ppt每个算法的逐个总结，<strong>非官方出品</strong>。不得不说潘老师的英文ppt看着真是有点痛苦，能去童老师蹭课还是去蹭一下吧，不要像我当年一样懒，期末啃了半天算法还是考的稀烂。但不得不说北航的算法考的还是比较友好的，除了最后一个题有点难度其他基本是送分，当然平时作业好好理解的话都拿下也是完全可能的。</p>
<h2 id="一、时间复杂度"><a href="#一、时间复杂度" class="headerlink" title="一、时间复杂度"></a>一、时间复杂度</h2><h3 id="1-1-主定理（简化形式）"><a href="#1-1-主定理（简化形式）" class="headerlink" title="1.1 主定理（简化形式）"></a>1.1 主定理（简化形式）</h3><p>对形如 $T(n) &#x3D; aT(n&#x2F;b) + n^k$ 的递归式：</p>
<p>$T(n) &#x3D; O(n^k),\ if\ k &gt; log_ba$<br>$T(n) &#x3D; O(n^klogn),\ if\ k &#x3D; log_ba$<br>$T(n) &#x3D; O(n^{log_ba}),\ if\ k &lt; log_ba$</p>
<h2 id="二、分治"><a href="#二、分治" class="headerlink" title="二、分治"></a>二、分治</h2><h3 id="2-1-最大连续子数组"><a href="#2-1-最大连续子数组" class="headerlink" title="2.1 最大连续子数组"></a>2.1 最大连续子数组</h3><h4 id="2-1-1-问题定义"><a href="#2-1-1-问题定义" class="headerlink" title="2.1.1 问题定义"></a>2.1.1 问题定义</h4><p>找一个数组中和最大的子数组</p>
<h4 id="2-1-2-算法"><a href="#2-1-2-算法" class="headerlink" title="2.1.2 算法"></a>2.1.2 算法</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/algorithm/MCS.jpg"
                      alt="MCS"
                ></p>
<h4 id="2-1-3-分析"><a href="#2-1-3-分析" class="headerlink" title="2.1.3 分析"></a>2.1.3 分析</h4><p>依据主定理，两个递归式的时间复杂度分别为$T(n&#x2F;2)$，总的时间复杂度递推式为$T(n) &#x3D; 2T(n&#x2F;2) + n$，时间复杂度为$O(nlogn)$。（用动态规划可以缩小到$O(n)$）</p>
<h3 id="2-2-逆序对的个数"><a href="#2-2-逆序对的个数" class="headerlink" title="2.2 逆序对的个数"></a>2.2 逆序对的个数</h3><h4 id="2-2-1-问题定义"><a href="#2-2-1-问题定义" class="headerlink" title="2.2.1 问题定义"></a>2.2.1 问题定义</h4><p>给定一个序列有n个数，求n个数中逆序对的个数，逆序对的定义：$i &lt; j\ &amp;&amp;\ a[i] &gt; a[j]$。</p>
<h4 id="2-2-2-算法"><a href="#2-2-2-算法" class="headerlink" title="2.2.2 算法"></a>2.2.2 算法</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/algorithm/CountInversion1.jpg"
                      alt="CountingInversion1"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/algorithm/CountInversion2.jpg"
                      alt="CountingInversion2"
                ></p>
<h4 id="2-2-3-分析"><a href="#2-2-3-分析" class="headerlink" title="2.2.3 分析"></a>2.2.3 分析</h4><p>时间复杂度：$O(nlogn)$</p>
<h3 id="2-3-快速排序"><a href="#2-3-快速排序" class="headerlink" title="2.3 快速排序"></a>2.3 快速排序</h3><h4 id="2-3-1-问题定义"><a href="#2-3-1-问题定义" class="headerlink" title="2.3.1 问题定义"></a>2.3.1 问题定义</h4><p>核心思想就是每次选一个pivot，将所有小于pivot的元素放在pivot左边，将所有大于pivot的元素放在pivot右边。最后能得到pivot左右两边各有一个子数组，重复该步骤。具体过程比较复杂，课件上的例子也没有，直接背代码就完事了。</p>
<h4 id="2-3-2-算法"><a href="#2-3-2-算法" class="headerlink" title="2.3.2 算法"></a>2.3.2 算法</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/algorithm/4.jpg"
                      alt="QuickSort"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/algorithm/5.jpg"
                      alt="Partition"
                ></p>
<h4 id="2-3-3-分析"><a href="#2-3-3-分析" class="headerlink" title="2.3.3 分析"></a>2.3.3 分析</h4><p>时间复杂度：$O(nlogn)$</p>
<h2 id="三、动态规划"><a href="#三、动态规划" class="headerlink" title="三、动态规划"></a>三、动态规划</h2><h3 id="3-1-0-1背包问题"><a href="#3-1-0-1背包问题" class="headerlink" title="3.1 0-1背包问题"></a>3.1 0-1背包问题</h3><h4 id="3-1-1-问题定义"><a href="#3-1-1-问题定义" class="headerlink" title="3.1.1 问题定义"></a>3.1.1 问题定义</h4><p>给定背包容量W，和每个物品的价值v和重量w，<strong>每个物品只有一件</strong>，求怎么装价值最大。</p>
<h4 id="3-1-2-算法"><a href="#3-1-2-算法" class="headerlink" title="3.1.2 算法"></a>3.1.2 算法</h4><p><strong>状态转移方程</strong>：$V[i][w] &#x3D; max(V[i-1][w], V[i-1][w-w_i] + v[i])$<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/algorithm/6.jpg"
                      alt="Knapsack"
                ></p>
<h4 id="3-1-3-分析"><a href="#3-1-3-分析" class="headerlink" title="3.1.3 分析"></a>3.1.3 分析</h4><p>时间复杂度：$O(nW)$</p>
<h3 id="3-2-钢条切割问题"><a href="#3-2-钢条切割问题" class="headerlink" title="3.2 钢条切割问题"></a>3.2 钢条切割问题</h3><h4 id="3-2-1-问题定义"><a href="#3-2-1-问题定义" class="headerlink" title="3.2.1 问题定义"></a>3.2.1 问题定义</h4><p>给定一条绳子的总长度，和不同长度的绳子对应的价值，求怎么切价值最大</p>
<h4 id="3-2-2-算法"><a href="#3-2-2-算法" class="headerlink" title="3.2.2 算法"></a>3.2.2 算法</h4><p><strong>状态转移方程</strong>：$dp[j] &#x3D; max_{i&#x3D;1}^{\ j}(\ v[i] + dp[j-i])$<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/algorithm/7.jpg"
                      alt="RodCutting"
                ></p>
<h4 id="3-2-3-分析"><a href="#3-2-3-分析" class="headerlink" title="3.2.3 分析"></a>3.2.3 分析</h4><p>时间复杂度：$O(n^2)$</p>
<h3 id="3-3-最小编辑距离"><a href="#3-3-最小编辑距离" class="headerlink" title="3.3 最小编辑距离"></a>3.3 最小编辑距离</h3><h4 id="3-3-1-问题定义"><a href="#3-3-1-问题定义" class="headerlink" title="3.3.1 问题定义"></a>3.3.1 问题定义</h4><p>两个单词 word1 和 word2，返回将 word1 转换成 word2 所使用的最少操作数。<br>操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<h4 id="3-3-2-算法"><a href="#3-3-2-算法" class="headerlink" title="3.3.2 算法"></a>3.3.2 算法</h4><p><strong>状态转移方程</strong>：如果$X_i &#x3D; Y_j$, substitutionCost &#x3D; 0，否则substitutionCost &#x3D; 1，最终的转移方程为：<br>$dp[i][j] &#x3D; min(dp[i-1][j] + 1, dp[i][j-1] + 1, dp[i-1][j-1] + substitutionCost)$<br>其中第一项为增加操作的代价（从$X_{i-1}$到$Y_j$），第二项为删除操作的代价（从$X_{i}$到$Y_{j-1}$），第三项为替换操作的代价。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/algorithm/8.jpg"
                      alt="MED1"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/algorithm/9.jpg"
                      alt="MED2"
                ></p>
<h4 id="3-3-3-分析"><a href="#3-3-3-分析" class="headerlink" title="3.3.3 分析"></a>3.3.3 分析</h4><p>时间复杂度：$O(mn)$，其中m为word1的长度，n为word2的长度。</p>
<h3 id="3-4-矩阵连乘"><a href="#3-4-矩阵连乘" class="headerlink" title="3.4 矩阵连乘"></a>3.4 矩阵连乘</h3><h4 id="3-4-1-问题定义"><a href="#3-4-1-问题定义" class="headerlink" title="3.4.1 问题定义"></a>3.4.1 问题定义</h4><p>给定n个矩阵，确定计算矩阵连乘积的计算次序，使得到正确结果需要付出的代价最少。</p>
<h4 id="3-4-2-算法"><a href="#3-4-2-算法" class="headerlink" title="3.4.2 算法"></a>3.4.2 算法</h4><p><strong>状态转移方程</strong>：$dp[i][j] &#x3D; min_{i\leq k \leq j}(dp[i, k] + dp[k+1, j] + p_{i-1}p_kp_j)$<br><strong>对该状态转移方程的理解</strong>：首先，一个规模为 $(i, j)$ 的矩阵与一个规模为 $(j, k)$的矩阵相乘，乘积次数为 $i<em>j</em>k$。该状态转移方程由三部分构成，把第i个矩阵到第j个矩阵从第k个矩阵分开，第一部分为第i到k个矩阵相乘的次数，第二部分为第k到j个矩阵相乘的次数，第三部分也是最难理解的部分，是把前两部分得到的两个矩阵再相乘的次数。第i个矩阵的维度是$(p_{i-1}, p_i)$，第i到k个矩阵相乘得到的矩阵的维度是$(p_{i-1}, p_k)$，第k到j个矩阵相乘得到的矩阵的维度是$(p_{k}, p_j)$，所以两部分合起来的次数是$p_{i-1}p_kp_j$。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/algorithm/10.jpg"
                      alt="MatrixMult"
                ></p>
<h4 id="3-4-3-分析"><a href="#3-4-3-分析" class="headerlink" title="3.4.3 分析"></a>3.4.3 分析</h4><p>时间复杂度：$O(n^3)$</p>
<h3 id="3-5-最长公共子序列"><a href="#3-5-最长公共子序列" class="headerlink" title="3.5 最长公共子序列"></a>3.5 最长公共子序列</h3><h4 id="3-5-1-问题定义"><a href="#3-5-1-问题定义" class="headerlink" title="3.5.1 问题定义"></a>3.5.1 问题定义</h4><p>给定两个字符串 s1 和 s2，返回这两个字符串的最长公共子序列的长度。子序列的定义：由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<strong>子序列不一定连续</strong>。</p>
<h4 id="3-5-2-算法"><a href="#3-5-2-算法" class="headerlink" title="3.5.2 算法"></a>3.5.2 算法</h4><p><strong>状态转移方程</strong>：<br>如果$s1[i] &#x3D; s2[j]$，有 $dp[i][j] &#x3D; dp[i-1][j-1] + 1$；<br>否则有 $dp[i][j] &#x3D; max(dp[i][j-1], dp[i-1][j])$<br><strong>对该状态转移方程的理解</strong>：令$Z_k$表示LCS。如果$s1[i] &#x3D; s2[j]$，说明$Z_{k-1}$是$X_{i-1}$和$Y_{j-1}$的最大公共子序列，所以$X_{i}$和$Y_{j}$的LCS长度就等于$X_{i-1}$和$Y_{j-1}$的LCS长度+1。<br>否则，说明LCS并不以$x_i$或$y_j$结尾，此时的$Z_k$既是$X_i$、$Y_{j-1}$的LCS，也是$X_{i-1}$、$Y_{j}$的LCS，我们取二者之间较大的那个。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/algorithm/11.jpg"
                      alt="LCS1"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/algorithm/12.jpg"
                      alt="LCS2"
                ></p>
<h4 id="3-5-3-分析"><a href="#3-5-3-分析" class="headerlink" title="3.5.3 分析"></a>3.5.3 分析</h4><p>时间复杂度：$O(mn)$</p>
<h4 id="3-5-4-类似问题：最大公共子串"><a href="#3-5-4-类似问题：最大公共子串" class="headerlink" title="3.5.4 类似问题：最大公共子串"></a>3.5.4 类似问题：最大公共子串</h4><p><strong>区别</strong>：子序列不要求连续，子串要求连续。<br><strong>改进状态转移方程</strong>：<br>如果$s1[i] &#x3D; s2[j]$，有 $dp[i][j] &#x3D; dp[i-1][j-1] + 1$；<br>否则有 $dp[i][j] &#x3D; 0$</p>
<h2 id="四、贪心"><a href="#四、贪心" class="headerlink" title="四、贪心"></a>四、贪心</h2><h3 id="4-1-分数背包问题"><a href="#4-1-分数背包问题" class="headerlink" title="4.1 分数背包问题"></a>4.1 分数背包问题</h3><h4 id="4-1-1-问题定义"><a href="#4-1-1-问题定义" class="headerlink" title="4.1.1 问题定义"></a>4.1.1 问题定义</h4><p>与0-1背包的区别：每个物品可以取它的一部分，不再是只有取或不取。同样是求总价值最大。</p>
<h4 id="4-1-2-算法"><a href="#4-1-2-算法" class="headerlink" title="4.1.2 算法"></a>4.1.2 算法</h4><p>每个物品按照单位价值（价值比上重量）排序，紧着性价比高的选。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/algorithm/13.jpg"
                      alt="FractionKnapsack"
                ></p>
<h4 id="4-1-3-分析"><a href="#4-1-3-分析" class="headerlink" title="4.1.3 分析"></a>4.1.3 分析</h4><p>排序的时间复杂度是$O(nlogn)$，装填的时间复杂度是$O(n)$，总时间复杂度是$O(nlogn)$。</p>
<h3 id="4-2-活动选择问题"><a href="#4-2-活动选择问题" class="headerlink" title="4.2 活动选择问题"></a>4.2 活动选择问题</h3><h4 id="4-2-1-问题定义"><a href="#4-2-1-问题定义" class="headerlink" title="4.2.1 问题定义"></a>4.2.1 问题定义</h4><p>给定若干个活动，活动有开始时间和结束时间，活动之间不能重叠，求怎么安排能去的活动最多。</p>
<h4 id="4-2-2-算法"><a href="#4-2-2-算法" class="headerlink" title="4.2.2 算法"></a>4.2.2 算法</h4><p>步骤：</p>
<ol>
<li>按结束时间最短排序</li>
<li>一旦选了一个活动，把所有重叠的活动删掉</li>
<li>重复以上步骤</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/algorithm/14.jpg"
                      alt="ActivitySelection"
                ></p>
<h4 id="4-2-3-分析"><a href="#4-2-3-分析" class="headerlink" title="4.2.3 分析"></a>4.2.3 分析</h4><p>时间复杂度：$O(nlogn)$。</p>
<h4 id="4-2-4-衍生问题：带权重的活动选择"><a href="#4-2-4-衍生问题：带权重的活动选择" class="headerlink" title="4.2.4 衍生问题：带权重的活动选择"></a>4.2.4 衍生问题：带权重的活动选择</h4><p><strong>区别</strong>：活动带权重，目标改成了总权重最大。改用动态规划。<br><strong>状态转移方程</strong>：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/algorithm/15.jpg"
                      alt="WeighedActivitySelection"
                ><br>仍然是先对所有活动按最早结束时间排序，然后按照这个状态转移方程写动态规划。其中，p(j)是与j不冲突的结束最晚的活动。<br><strong>时间复杂度</strong>：$O(nlogn)$</p>
<h3 id="4-3-哈夫曼编码"><a href="#4-3-哈夫曼编码" class="headerlink" title="4.3 哈夫曼编码"></a>4.3 哈夫曼编码</h3><h4 id="4-3-1-问题定义"><a href="#4-3-1-问题定义" class="headerlink" title="4.3.1 问题定义"></a>4.3.1 问题定义</h4><p>给定一个若干个字符与出现频率，求平均编码长度最短的编码方式。</p>
<h4 id="4-3-2-算法"><a href="#4-3-2-算法" class="headerlink" title="4.3.2 算法"></a>4.3.2 算法</h4><p>步骤：</p>
<ol>
<li>借助优先队列，将所有字符按出现频率从低到高排序</li>
<li>每次选择出现频率最小的两个构成一个新的节点，重新入队</li>
<li>重复以上步骤<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/algorithm/16.jpg"
                      alt="Huffman"
                ></li>
</ol>
<h4 id="4-3-3-分析"><a href="#4-3-3-分析" class="headerlink" title="4.3.3 分析"></a>4.3.3 分析</h4><p>时间复杂度：$O(nlogn)$</p>
<h2 id="五、图"><a href="#五、图" class="headerlink" title="五、图"></a>五、图</h2><h3 id="5-1-BFS"><a href="#5-1-BFS" class="headerlink" title="5.1 BFS"></a>5.1 BFS</h3><h4 id="5-1-1-问题定义"><a href="#5-1-1-问题定义" class="headerlink" title="5.1.1 问题定义"></a>5.1.1 问题定义</h4><p>广度优先搜索，用队列，每次弹出一个顶点，把邻接结点入队</p>
<h4 id="5-1-2-算法"><a href="#5-1-2-算法" class="headerlink" title="5.1.2 算法"></a>5.1.2 算法</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/algorithm/17.jpg"
                      alt="BFS"
                ></p>
<h4 id="5-1-3-分析"><a href="#5-1-3-分析" class="headerlink" title="5.1.3 分析"></a>5.1.3 分析</h4><p>时间复杂度：$O(V+E)$</p>
<h3 id="5-2-DFS"><a href="#5-2-DFS" class="headerlink" title="5.2 DFS"></a>5.2 DFS</h3><h4 id="5-2-1-问题定义"><a href="#5-2-1-问题定义" class="headerlink" title="5.2.1 问题定义"></a>5.2.1 问题定义</h4><p>深度优先搜索</p>
<h3 id="5-2-2-算法"><a href="#5-2-2-算法" class="headerlink" title="5.2.2 算法"></a>5.2.2 算法</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/algorithm/18.jpg"
                      alt="DFS1"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/algorithm/19.jpg"
                      alt="DFS2"
                ></p>
<h4 id="5-2-3-分析"><a href="#5-2-3-分析" class="headerlink" title="5.2.3 分析"></a>5.2.3 分析</h4><p>时间复杂度：$O(V+E)$</p>
<h3 id="5-3-拓扑排序"><a href="#5-3-拓扑排序" class="headerlink" title="5.3 拓扑排序"></a>5.3 拓扑排序</h3><h4 id="5-3-1-问题定义"><a href="#5-3-1-问题定义" class="headerlink" title="5.3.1 问题定义"></a>5.3.1 问题定义</h4><p>一个有向无环图（DAG），按照结点先后顺序排序（拓扑序不唯一）。<br>步骤：每次找一个入度为0的点，删去所有以它为端点的边，重复直到删去所有点。</p>
<h4 id="5-3-2-算法"><a href="#5-3-2-算法" class="headerlink" title="5.3.2 算法"></a>5.3.2 算法</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/algorithm/20.jpg"
                      alt="TopoSort"
                ></p>
<h4 id="5-3-3-分析"><a href="#5-3-3-分析" class="headerlink" title="5.3.3 分析"></a>5.3.3 分析</h4><p>时间复杂度：$O(V+E)$</p>
<h3 id="5-4-强连通分量"><a href="#5-4-强连通分量" class="headerlink" title="5.4 强连通分量"></a>5.4 强连通分量</h3><h4 id="5-4-1-问题定义"><a href="#5-4-1-问题定义" class="headerlink" title="5.4.1 问题定义"></a>5.4.1 问题定义</h4><p>强连通分量：有向图中，任意两点都有路径。（不能单向路径，必须有来回）</p>
<h4 id="5-4-2-算法"><a href="#5-4-2-算法" class="headerlink" title="5.4.2 算法"></a>5.4.2 算法</h4><p>步骤：</p>
<ol>
<li>先求G的反向图$G^R$</li>
<li>在$G^R$上DFS，得到一个序列$L^R$（当有一个结点遍历完所有邻居的时候，就把它放进$ L^R$）</li>
<li>将$L^R$反向得到L</li>
<li>按以下规则对L进行DFS<ol>
<li>从L的第一个结点开始</li>
<li>当一次重新开始后，从L的第一个未遍历过的顶点开始</li>
</ol>
</li>
<li>输出<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/algorithm/21.jpg"
                      alt="SCC"
                ></li>
</ol>
<h4 id="5-4-3-分析"><a href="#5-4-3-分析" class="headerlink" title="5.4.3 分析"></a>5.4.3 分析</h4><p>时间复杂度：$O(V+E)$</p>
<h3 id="5-5-Prim算法"><a href="#5-5-Prim算法" class="headerlink" title="5.5 Prim算法"></a>5.5 Prim算法</h3><h4 id="5-5-1-问题定义"><a href="#5-5-1-问题定义" class="headerlink" title="5.5.1 问题定义"></a>5.5.1 问题定义</h4><p>无向有权图，求最小生成树</p>
<h4 id="5-5-2-算法"><a href="#5-5-2-算法" class="headerlink" title="5.5.2 算法"></a>5.5.2 算法</h4><p>步骤：每次都将已经构造出的树看成一个顶点，求将邻接顶点中权值最小的边放进最小生成树。需要维护一个优先队列<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/algorithm/22.jpg"
                      alt="Prim"
                ></p>
<h4 id="5-5-3-分析"><a href="#5-5-3-分析" class="headerlink" title="5.5.3 分析"></a>5.5.3 分析</h4><p>时间复杂度：$O(ElogV)$</p>
<h3 id="5-6-Kruskal算法"><a href="#5-6-Kruskal算法" class="headerlink" title="5.6 Kruskal算法"></a>5.6 Kruskal算法</h3><h4 id="5-6-1-问题定义"><a href="#5-6-1-问题定义" class="headerlink" title="5.6.1 问题定义"></a>5.6.1 问题定义</h4><p>无向有权图，求最小生成树</p>
<h4 id="5-6-2-算法"><a href="#5-6-2-算法" class="headerlink" title="5.6.2 算法"></a>5.6.2 算法</h4><p>步骤：先对所有边排序，每次都选择最小的边加入最小生成树，如果加入这条边构成了一个环，就删掉这条边。是否成环需要用并查集判断。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/algorithm/23.jpg"
                      alt="Kruskal"
                ></p>
<h4 id="5-6-3-分析"><a href="#5-6-3-分析" class="headerlink" title="5.6.3 分析"></a>5.6.3 分析</h4><p>时间复杂度：$O(ElogV)$</p>
<h3 id="5-7-Dijkstra"><a href="#5-7-Dijkstra" class="headerlink" title="5.7 Dijkstra"></a>5.7 Dijkstra</h3><h4 id="5-7-1-单源最短路径"><a href="#5-7-1-单源最短路径" class="headerlink" title="5.7.1 单源最短路径"></a>5.7.1 单源最短路径</h4><p>有向带<strong>正</strong>权图，单源最短路径</p>
<h4 id="5-7-2-算法"><a href="#5-7-2-算法" class="headerlink" title="5.7.2 算法"></a>5.7.2 算法</h4><p>借助优先队列，遍历到一个结点，看从它到它的邻接顶点的距离是否小于原来的距离，如果小于就更新。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/algorithm/24.jpg"
                      alt="Dijkstra"
                ></p>
<h4 id="5-7-3-分析"><a href="#5-7-3-分析" class="headerlink" title="5.7.3 分析"></a>5.7.3 分析</h4><p>时间复杂度：$O(ElogV)$</p>
<h3 id="5-8-Bellman-Ford"><a href="#5-8-Bellman-Ford" class="headerlink" title="5.8 Bellman-Ford"></a>5.8 Bellman-Ford</h3><h4 id="5-8-1-问题定义"><a href="#5-8-1-问题定义" class="headerlink" title="5.8.1 问题定义"></a>5.8.1 问题定义</h4><p>单源最短路径，可以带负权</p>
<h4 id="5-8-2-算法"><a href="#5-8-2-算法" class="headerlink" title="5.8.2 算法"></a>5.8.2 算法</h4><p>如果有负环就返回false。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/algorithm/25.jpg"
                      alt="BellmanFord"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/algorithm/26.jpg"
                      alt="Relax"
                ></p>
<h4 id="5-8-3-分析"><a href="#5-8-3-分析" class="headerlink" title="5.8.3 分析"></a>5.8.3 分析</h4><p>时间复杂度：$O(V*E)$</p>
<h3 id="5-9-Floyd"><a href="#5-9-Floyd" class="headerlink" title="5.9 Floyd"></a>5.9 Floyd</h3><h4 id="5-9-1-问题定义"><a href="#5-9-1-问题定义" class="headerlink" title="5.9.1 问题定义"></a>5.9.1 问题定义</h4><p>所有点的最短路径，图可以带负权，但不能带负环</p>
<h4 id="5-9-2-算法"><a href="#5-9-2-算法" class="headerlink" title="5.9.2 算法"></a>5.9.2 算法</h4><p>动态规划，状态转移方程：<br>$d_{ij}^k &#x3D; min(d_{ij}^{k-1}, d_{ik}^{k-1} + d_{kj}^{k-1})$<br>遍历k次，每次选第k个结点作为中间节点<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/algorithm/27.jpg"
                      alt="Floyd"
                ><br>输出结果的算法<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/algorithm/28.jpg"
                      alt="Path"
                ></p>
<h4 id="5-9-3-分析"><a href="#5-9-3-分析" class="headerlink" title="5.9.3 分析"></a>5.9.3 分析</h4><p>时间复杂度：$O(n^3)$</p>
<h3 id="5-10-Ford-Fulkson"><a href="#5-10-Ford-Fulkson" class="headerlink" title="5.10 Ford-Fulkson"></a>5.10 Ford-Fulkson</h3><h4 id="5-10-1-问题定义"><a href="#5-10-1-问题定义" class="headerlink" title="5.10.1 问题定义"></a>5.10.1 问题定义</h4><p>求最大流问题</p>
<h4 id="5-10-2-算法"><a href="#5-10-2-算法" class="headerlink" title="5.10.2 算法"></a>5.10.2 算法</h4><p>augmenting path增广路径<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/algorithm/29.jpg"
                      alt="Augment"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/algorithm/30.jpg"
                      alt="FolkFulkerson"
                ></p>
<h4 id="5-10-3-分析"><a href="#5-10-3-分析" class="headerlink" title="5.10.3 分析"></a>5.10.3 分析</h4><p>时间复杂度：取决于最大流量，可能很糟，但更好的算法也没讲</p>
]]></content>
      <categories>
        <category>专业课</category>
      </categories>
      <tags>
        <tag>知识点总结</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>OS-Lab6-挑战性任务 实验报告</title>
    <url>/2024/08/18/OS-Lab6-Challenge-Experiment-Report/</url>
    <content><![CDATA[<h1 id="Lab6挑战性任务实验报告"><a href="#Lab6挑战性任务实验报告" class="headerlink" title="Lab6挑战性任务实验报告"></a>Lab6挑战性任务实验报告</h1><p>具体代码见: <a class="link"   href="https://github.com/goldenkm/BUAA-OS-2023-Spring" >BUAA-OS-2023-Spring <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="一、各项任务实现思路"><a href="#一、各项任务实现思路" class="headerlink" title="一、各项任务实现思路"></a>一、各项任务实现思路</h2><h3 id="必做部分"><a href="#必做部分" class="headerlink" title="必做部分"></a>必做部分</h3><h4 id="1-1-实现一行多命令"><a href="#1-1-实现一行多命令" class="headerlink" title="1.1 实现一行多命令"></a>1.1 实现一行多命令</h4><p>在Lab6的挑战性任务中，我们接触到的第一个任务是实现“；”的功能，这一功能不算太难，整体上参考实验代码中管道的实现即可，代码如下所示。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;;&#x27;</span>:	<span class="comment">//lab6-challenge</span></span><br><span class="line">	child = fork();</span><br><span class="line">	*rightpipe = child;</span><br><span class="line">	<span class="comment">//重点在于让父亲执行分号右边的指令。</span></span><br><span class="line">	<span class="keyword">if</span> (child &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		wait(child);</span><br><span class="line">		<span class="keyword">return</span> parsecmd(argv, rightpipe);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (child == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> argc;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		user_panic(<span class="string">&quot;fork error!\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></div>
<p>这一功能需要注意的地方是为了<strong>依次</strong>实现分号两侧的命令，需要让父进程执行分号右边的指令，并且等待子进程结束才执行，我们可以通过wait函数来控制指令执行的顺序。</p>
<h4 id="1-2-实现后台任务"><a href="#1-2-实现后台任务" class="headerlink" title="1.2 实现后台任务"></a>1.2 实现后台任务</h4><p>第二个任务是实现“&amp;”，实现思路是让父进程执行&amp;右侧的指令，子进程执行&amp;左侧的指令，但此时父进程无需等待子进程。shell的读取机制是读到下一条之前一直忙等，其余进程都被阻塞，所以可以让父进程不被阻塞住，继续执行之后读入的命令，子进程继续执行该命令。代码如下所示。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//parse_cmd()</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;&amp;&#x27;</span>: </span><br><span class="line">	child = fork();</span><br><span class="line">	<span class="keyword">if</span> (child == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> argc;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (child &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> parsecmd(argv, <span class="number">0</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		user_panic(<span class="string">&quot;fork error!\n&quot;</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="1-3-实现引号支持"><a href="#1-3-实现引号支持" class="headerlink" title="1.3 实现引号支持"></a>1.3 实现引号支持</h4><p>该任务的实现思路是_gettoken()函数中对引号进行特判，当读到右引号时结束特判，过程有点像一道大一的程设题。为了向真实的linux的shell靠拢，我加入了转义符的实现，主要难点在于对于循环结束条件的判断比较复杂。代码如下所示，这里的代码保障了不会因为识别到被转义过的双引号而结束（如：\“)。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//_gettoken()</span></span><br><span class="line"><span class="comment">//实现引号支持</span></span><br><span class="line"><span class="keyword">if</span> (*s == <span class="string">&#x27;\&quot;&#x27;</span>) &#123;</span><br><span class="line">    *p1 = ++s;</span><br><span class="line">	<span class="keyword">while</span> ((*s != <span class="string">&#x27;\&quot;&#x27;</span> || *(s<span class="number">-1</span>) == <span class="string">&#x27;\\&#x27;</span>) </span><br><span class="line">                &amp;&amp; (*s != <span class="string">&#x27;\&quot;&#x27;</span> || *(s<span class="number">-1</span>) != <span class="string">&#x27;\\&#x27;</span> || *(s<span class="number">-2</span>) != <span class="string">&#x27;\\&#x27;</span>)) &#123;</span><br><span class="line">		s++;</span><br><span class="line">	&#125;</span><br><span class="line">	*s++ = <span class="number">0</span>;	<span class="comment">//必须要封好字符串</span></span><br><span class="line">	*p2 = s;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;w&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>同时需要修改parse_cmd的部分：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//parse_cmd()</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">	<span class="keyword">if</span> (argc &gt;= MAXARGS) &#123;</span><br><span class="line">		debugf(<span class="string">&quot;too many arguments\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	remove_slash(t);</span><br><span class="line">	argv[argc++] = t;</span><br><span class="line"></span><br><span class="line"><span class="comment">//remove_slash()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">remove_slash</span><span class="params">(<span class="type">char</span> *t)</span> &#123;</span><br><span class="line">	<span class="type">char</span> tmp[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; t[i]; i++) &#123;</span><br><span class="line">            <span class="comment">//将需要转义的字符列举在这里</span></span><br><span class="line">	    <span class="type">int</span> flag = (t[i+<span class="number">1</span>] == <span class="string">&#x27;\&#x27;&#x27;</span>) || (t[i+<span class="number">1</span>] == <span class="string">&#x27;\&quot;&#x27;</span>);</span><br><span class="line">	    <span class="keyword">if</span> (t[i] == <span class="string">&#x27;\\&#x27;</span> &amp;&amp; t[i+<span class="number">1</span>] == <span class="string">&#x27;\\&#x27;</span>) &#123;</span><br><span class="line">	    	tmp[length++] = <span class="string">&#x27;\\&#x27;</span>;</span><br><span class="line">	    	i++;</span><br><span class="line">	    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t[i] == <span class="string">&#x27;\\&#x27;</span> &amp;&amp; flag) &#123;</span><br><span class="line">	    	<span class="keyword">continue</span>;</span><br><span class="line">	    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    	tmp[length++] = t[i];</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	tmp[length] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	<span class="built_in">strcpy</span>(t, tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>我新写了一个remove_slash的函数用于去除转义符。这里我只考虑了单双引号与\的转义，但也留出了日后添加转义符的空间，具有良好的可扩展性。</p>
<h4 id="1-4-实现键入命令时任意位置的修改"><a href="#1-4-实现键入命令时任意位置的修改" class="headerlink" title="1.4 实现键入命令时任意位置的修改"></a>1.4 实现键入命令时任意位置的修改</h4><p>从这一要求开始Lab6的挑战性任务的难度陡然而升，因为涉及到了与外设的交互。首先，经过查阅资料与试验，上下左右四个键的ascii码与我们平时接触到的字符不太一样，这四个键分为了三个值表示，分别是27+91+65&#x2F;66&#x2F;67&#x2F;68（依次对应上下左右）。<br>具体的实现思路是：为了实现在不同位置的增加删除，需要设置一个pointer，专门记录当前光标所在的位置，每次在pointer处读入字符。若是读入字符的位置有字符，即对应增加字符的情况，就把从pointer到结尾的内容都先暂存起来，再用strcat把这几部分拼接起来。同时需要注意光标位置的挪动，我的方法是输出空格消除控制台的输出，然后输出退格键将光标位置挪回来。删除的情况与之类似。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读入左右键时的情况</span></span><br><span class="line"><span class="comment">//readline()</span></span><br><span class="line"><span class="keyword">if</span> (buf[i+<span class="number">2</span>] == <span class="number">68</span>) &#123; <span class="comment">//left</span></span><br><span class="line">    <span class="keyword">if</span> (pointer &gt; <span class="number">0</span>) &#123; <span class="comment">//注意左右移动光标需要有个极限</span></span><br><span class="line">    	pointer--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (buf[i+<span class="number">2</span>] == <span class="number">67</span>) &#123; <span class="comment">//right</span></span><br><span class="line">    <span class="keyword">if</span> (cmd[pointer] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        pointer++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***********正常读入字符***********/</span></span><br><span class="line"><span class="keyword">if</span> (cmd[pointer] != <span class="number">0</span>) &#123;    <span class="comment">//增加字符</span></span><br><span class="line">    <span class="type">char</span> tmp[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = pointer; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cmd[j] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp[length++] = cmd[j];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);    <span class="comment">//清空控制台</span></span><br><span class="line">    &#125;</span><br><span class="line">    tmp[length] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\b&quot;</span>);   <span class="comment">//将光标挪回来</span></span><br><span class="line">    &#125;</span><br><span class="line">    cmd[pointer++] = buf[i];    </span><br><span class="line">    cmd[pointer] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">strcat</span>(cmd, tmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, tmp[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cmd[pointer++] = buf[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***********读入删除键***********/</span></span><br><span class="line"><span class="keyword">if</span> (buf[i] == <span class="number">127</span>) &#123; <span class="comment">//实现删除功能，与插入类似</span></span><br><span class="line">    <span class="type">char</span> tmp[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (pointer == <span class="number">0</span>) &#123; <span class="comment">//不能无止境的删除</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\b &quot;</span>);</span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = pointer; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cmd[j] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp[length++] = cmd[j];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    tmp[length] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= length; j++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cmd[--pointer] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">strcat</span>(cmd, tmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, tmp[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="1-5-实现程序名称中-b-的省略"><a href="#1-5-实现程序名称中-b-的省略" class="headerlink" title="1.5 实现程序名称中 .b 的省略"></a>1.5 实现程序名称中 .b 的省略</h4><p>这一任务相对简单，只需要当打不开文件时在文件名后面加上“.b“重新打开一遍即可。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/spawn.c</span></span><br><span class="line"><span class="keyword">if</span> ((fd = open(prog, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">char</span> prog1[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;; </span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; prog[i] != <span class="number">0</span>; i++) &#123;</span><br><span class="line">    prog1[i] = prog[i];</span><br><span class="line">    &#125;</span><br><span class="line">    prog1[i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    prog1[i+<span class="number">1</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    prog1[i+<span class="number">2</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(prog1, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="1-6-实现更丰富的命令"><a href="#1-6-实现更丰富的命令" class="headerlink" title="1.6 实现更丰富的命令"></a>1.6 实现更丰富的命令</h4><h5 id="1-6-1-tree"><a href="#1-6-1-tree" class="headerlink" title="1.6.1 tree"></a>1.6.1 tree</h5><p>实现tree命令可以参考实验代码里的ls.c文件，循环读目录里的文件，如果这个文件也是个目录，就递归读取，并记录递归的层数以形式化输出。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/tree.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tree</span><span class="params">(<span class="type">char</span> *path, <span class="type">int</span> level)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd, n;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">f</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(path, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    	user_panic(<span class="string">&quot;open %s: %d&quot;</span>, path, fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((n = readn(fd, &amp;f, <span class="keyword">sizeof</span> f)) == <span class="keyword">sizeof</span> f) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (f.f_name[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">                debugf(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            debugf(<span class="string">&quot;|--&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (f.f_type == FTYPE_REG) &#123;</span><br><span class="line">            	debugf(<span class="string">&quot;%s\n&quot;</span>, f.f_name);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f.f_type == FTYPE_DIR) &#123;</span><br><span class="line">                debugf(<span class="string">&quot;%s\n&quot;</span>, f.f_name);</span><br><span class="line">                <span class="type">char</span> newPath[<span class="number">1024</span>];</span><br><span class="line">                <span class="built_in">strcpy</span>(newPath, path);</span><br><span class="line">                <span class="built_in">strcat</span>(newPath, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">                <span class="built_in">strcat</span>(newPath, f.f_name);</span><br><span class="line">                tree(newPath, level+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="1-6-2-mkdir"><a href="#1-6-2-mkdir" class="headerlink" title="1.6.2 mkdir"></a>1.6.2 mkdir</h5><p>mkdir的实现思路：先将路径里的文件拆分，存进二维数组；再分成两种情况，该指令可以添加-p的选项，如果添加-p就可以实现如果遇到不存在的目录就创建，反之则会报错。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> flag[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dir_is_exist</span><span class="params">(<span class="type">char</span> *path)</span> &#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	fd = open(path, O_RDONLY);</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> fd &gt;= <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">char</span> *path)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r, i, count = <span class="number">0</span>;;</span><br><span class="line">    <span class="type">char</span> dirs[<span class="number">50</span>][<span class="number">1024</span>];</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> pathLen = <span class="built_in">strlen</span>(path);</span><br><span class="line">    <span class="keyword">while</span> (i &lt; pathLen) &#123;</span><br><span class="line">        <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (path[i] != <span class="string">&#x27;/&#x27;</span> &amp;&amp; path[i]) &#123;</span><br><span class="line">            dirs[count][length++] = path[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        dirs[count++][length] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> now[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f</span>;</span></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; count) &#123;</span><br><span class="line">        <span class="built_in">strcat</span>(now, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(now, dirs[i]);</span><br><span class="line">        <span class="keyword">if</span> (flag[<span class="string">&#x27;p&#x27;</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dir_is_exist(now)) &#123;</span><br><span class="line">                create(now, FTYPE_DIR);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == count - <span class="number">1</span>) &#123; <span class="comment">//最后一个dir，要创建</span></span><br><span class="line">                create(now, FTYPE_DIR);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!dir_is_exist(now)) &#123;</span><br><span class="line">                    debugf(<span class="string">&quot;mkdir fail\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">usage</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;usage: mkdir [-p] [file...]\n&quot;</span>);</span><br><span class="line">	<span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">	ARGBEGIN &#123;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		usage();</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">		flag[(u_char)ARGC()]++;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ARGEND</span><br><span class="line">	<span class="title function_">for</span> <span class="params">(<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++)</span> &#123;</span><br><span class="line">		<span class="type">char</span> *path = parse_path(argv[i]);</span><br><span class="line">		mkdir(path);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="1-6-3-touch"><a href="#1-6-3-touch" class="headerlink" title="1.6.3 touch"></a>1.6.3 touch</h5><p>touch的实现与mkdir类似，只是将创建的文件的类型改为普通文件。这里只放上核心功能代码。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">touch</span><span class="params">(<span class="type">char</span> *path)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="type">char</span> realPath[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (path[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        realPath[<span class="number">0</span>] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcat</span>(realPath, path);</span><br><span class="line">    r = create(realPath, FTYPE_REG);</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        debugf(<span class="string">&quot;touch fail\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="1-6-4-O-CREAT与O-MKDIR"><a href="#1-6-4-O-CREAT与O-MKDIR" class="headerlink" title="1.6.4 O_CREAT与O_MKDIR"></a>1.6.4 O_CREAT与O_MKDIR</h5><p>O_CREAT与O_MKDIR是实验代码里已经内置好的两个宏定义。并且修改&#x2F;user&#x2F;serv.c里的serve_open函数，使其在打开文件时，若找不到该文件就创建一个。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Open the file.</span></span><br><span class="line">    <span class="keyword">if</span> ((r = file_open(rq-&gt;req_path, &amp;f)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="comment">//支持O_CREAT和O_MKDIR</span></span><br><span class="line">        <span class="keyword">if</span> (r == -E_NOT_FOUND &amp;&amp; (rq-&gt;req_omode &amp; O_CREAT)) &#123;</span><br><span class="line">            r = file_create(rq-&gt;req_path, &amp;f); </span><br><span class="line">            f-&gt;f_type = FTYPE_REG;</span><br><span class="line">            <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            	ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r == -E_NOT_FOUND &amp;&amp; (rq-&gt;req_omode &amp; O_MKDIR)) &#123;</span><br><span class="line">            r = file_create(rq-&gt;req_path, &amp;f);</span><br><span class="line">            f-&gt;f_type = FTYPE_DIR;</span><br><span class="line">            <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            	ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="1-7-实现历史命令功能"><a href="#1-7-实现历史命令功能" class="headerlink" title="1.7 实现历史命令功能"></a>1.7 实现历史命令功能</h4><p>历史功能实现思路：</p>
<ul>
<li>首先创建一个.history文件，创建一个his_pointer变量，指向当前.history里的那条指令。<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">history_init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> ((r = create(<span class="string">&quot;/.history&quot;</span>, FTYPE_REG)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        debugf(<span class="string">&quot;create .history fail\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        debugf(<span class="string">&quot;.history is created\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>当读入一个换行符时，打开.history，为了实现每次都将命令添加到文件的末尾，并且调用seek函数，寻找到文件的末尾，将当前的指令写入.history。同时也在fd.c中实现一个get_size函数，为了寻找到文件的末尾。<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***********读入回车键***********/</span></span><br><span class="line"><span class="keyword">if</span> (buf[i] == <span class="string">&#x27;\r&#x27;</span> || buf[i] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">    buf[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//存进历史记录里</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(<span class="string">&quot;/.history&quot;</span>, O_WRONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;open .history fail!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">if</span> ((size = get_size(fd)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;get size fail!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((r = seek(fd, size))) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;seek fail!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((r = write(fd, cmd, <span class="built_in">strlen</span>(cmd))) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;write .history fail!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((r = write(fd, <span class="string">&quot;\n&quot;</span>, <span class="number">1</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;write .history fail!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    his_num++;</span><br><span class="line">    his_pointer = his_num; <span class="comment">//每次读入回车都让指针指向最后一个</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>当读入上下键时，首先还是要控制光标的移动，其次是将.history文件中所有的指令存进一个二维数组，然后读出his_pointer处的指令，最后将当前控制台的输出清空，将这条历史指令输出到控制台。下展示读入上键时的代码，读入下键与之类似。<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//......</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (buf[i+<span class="number">2</span>] == <span class="number">65</span>) &#123; <span class="comment">//up</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c%c%c&quot;</span>, <span class="number">27</span>, <span class="number">91</span>, <span class="number">66</span>);</span><br><span class="line">    <span class="keyword">if</span> (his_pointer == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    his_pointer--;</span><br><span class="line">    <span class="type">char</span> tmp[<span class="number">128</span> * <span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> fd, count = <span class="number">0</span>, length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((fd =  open(<span class="string">&quot;/.history&quot;</span>, O_RDWR)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;open fail!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//保存当前的指令</span></span><br><span class="line">    cmd[pointer] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="comment">//读历史指令</span></span><br><span class="line">    <span class="keyword">if</span> ((r = read(fd, tmp, <span class="keyword">sizeof</span> tmp)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;read .history fail!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="comment">//存进二维数组</span></span><br><span class="line">    <span class="type">char</span> records[<span class="number">100</span>][<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; tmp[j]; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp[j] != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            records[count][length++] = tmp[j];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            records[count][length] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            count++;</span><br><span class="line">            length = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(cmd, records[his_pointer]);</span><br><span class="line">    <span class="comment">//清除当前控制台的输出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; pointer; j++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\b \b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pointer = <span class="built_in">strlen</span>(cmd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, cmd);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>最后实现history.c，当输入history指令时，将.history文件中都读出来，然后依次输出即可。</li>
</ul>
<h3 id="选做部分"><a href="#选做部分" class="headerlink" title="选做部分"></a>选做部分</h3><p>选做部分的两个功能都有实现，下面按照实现顺序依次介绍。</p>
<h4 id="选做部分-2：支持相对路径"><a href="#选做部分-2：支持相对路径" class="headerlink" title="选做部分 2：支持相对路径"></a>选做部分 2：支持相对路径</h4><p>实现思路：在进程控制块中加入一个当前路径的属性，运用系统调用改变当前所处路径和得到当前路径，增加系统调用的流程在上机的时候已经非常熟练了。在fork一个新进程时，需要让子进程复制父进程的当前路径。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="type">char</span> env_cur_path[<span class="number">1024</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kern/syscall_all.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_change_dir</span><span class="params">(<span class="type">char</span> *path)</span> &#123;</span><br><span class="line">	<span class="built_in">strcpy</span>(curenv-&gt;env_cur_path, path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">sys_get_cur_path</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> curenv-&gt;env_cur_path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>之后是实现cd与pwd的功能，这里要注意cd、pwd命令是内部命令，不能在外部文件中实现，要在sh.c内部实现。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/sh.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">chdir</span><span class="params">(<span class="type">char</span> *path)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *new_path = parse_path(path);</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(new_path, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;no such file or directory!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    syscall_change_dir(new_path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getcwd</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">char</span> cur_path[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="built_in">strcpy</span>(cur_path, syscall_get_cur_path());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, cur_path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main</span></span><br><span class="line"><span class="comment">/*********** 内部命令cd ***********/</span></span><br><span class="line"><span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">&#x27;c&#x27;</span> &amp;&amp; cmd[<span class="number">1</span>] == <span class="string">&#x27;d&#x27;</span>) &#123;</span><br><span class="line">    <span class="type">char</span> path[MAXPATHLEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; cmd[i]; i++) &#123;</span><br><span class="line">        path[i] = cmd[i + <span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    path[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    chdir(path);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*********** 内部命令pwd ***********/</span></span><br><span class="line"><span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">&#x27;p&#x27;</span> &amp;&amp; cmd[<span class="number">1</span>] == <span class="string">&#x27;w&#x27;</span> &amp;&amp; cmd[<span class="number">2</span>] == <span class="string">&#x27;d&#x27;</span>) &#123;</span><br><span class="line">    getcwd();</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>最后是要修改之前所有的指令，使之支持相对路径。为了增强代码的复用性，我在user&#x2F;lib中新建了一个path.c文件，实现了将相对路径转化为绝对路径的功能。具体将在下文实验难点一节中重点介绍。</p>
<h4 id="选做部分1：实现-shell-环境变量"><a href="#选做部分1：实现-shell-环境变量" class="headerlink" title="选做部分1：实现 shell 环境变量"></a>选做部分1：实现 shell 环境变量</h4><p>实现思路：</p>
<ul>
<li>同样也是需要在内核态更改，首先为了识别出父进程与子进程，需要给进程控制块编号，为1则为父进程，否则则为子进程，用以区分全局变量与环境变量。<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kern/syscall_all.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_set_shell_id</span><span class="params">()</span> &#123;</span><br><span class="line">	curenv-&gt;env_shell_id++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u_int <span class="title function_">sys_get_shell_id</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> curenv-&gt;env_shell_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>在内核态设置两个全局二维数组，分别为env_key[128][128]和env_value[128][128]，key和value一定是一一对应的，还有两个一维数组is_global和is_read_only用以标识环境变量是否为全局变量和是否为只读变量。并在内核态实现对于环境变量的get与set方法。当前shell的id为1时可以读局部变量，否则不行。此外，还需在include&#x2F;error.h中定义两种错误类型。<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> env_key[<span class="number">128</span>][<span class="number">128</span>];</span><br><span class="line"><span class="type">char</span> env_value[<span class="number">128</span>][<span class="number">128</span>];</span><br><span class="line"><span class="type">int</span> is_global[<span class="number">128</span>];</span><br><span class="line"><span class="type">int</span> is_read_only[<span class="number">128</span>];</span><br><span class="line"><span class="type">int</span> env_var_cnt;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_get_env_var</span><span class="params">(<span class="type">char</span> *key, <span class="type">char</span> *value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> global_perm = curenv-&gt;env_shell_id == <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; env_var_cnt; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(env_key[i], key) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!is_global[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (global_perm) &#123;</span><br><span class="line">                    <span class="built_in">strcpy</span>(value, env_value[i]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> -E_BAD_ENV_VAR;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">strcpy</span>(value, env_value[i]);    </span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -E_ENV_VAR_NOT_FOUND;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_set_env_var</span><span class="params">(<span class="type">char</span> *key, <span class="type">char</span> *value, <span class="type">int</span> global, <span class="type">int</span> read_only)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; env_var_cnt; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(key, env_key[i]) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (is_read_only[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> -E_BAD_ENV_VAR;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">strcpy</span>(env_value[i], value);</span><br><span class="line">            is_global[i] = global;</span><br><span class="line">            is_read_only[i] = read_only;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(env_key[env_var_cnt], key);</span><br><span class="line">    <span class="built_in">strcpy</span>(env_value[env_var_cnt], value);</span><br><span class="line">    is_global[env_var_cnt] = global;</span><br><span class="line">    is_read_only[env_var_cnt++] = read_only;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>实现declare.c，在该文件中先解析参数，将其按照“&#x3D;”两侧划分，再进行系统调用存储该环境变量。<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/declare.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">declare</span><span class="params">(<span class="type">char</span> *key, <span class="type">char</span> *value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> read_only = flag[<span class="string">&#x27;r&#x27;</span>];</span><br><span class="line">    <span class="type">int</span> global = flag[<span class="string">&#x27;x&#x27;</span>];</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> ((r = syscall_set_env_var(key, value, global, read_only)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;declare environment variable fail!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>实现declare命令，同样进行系统调用，打印所有环境变量。<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sys_print_env_var</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; env_var_cnt; i++) &#123;</span><br><span class="line">        printk(<span class="string">&quot;%d: name: %s value: %s\n&quot;</span>, i, env_key[i], env_value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>实现echo $name功能，对$进行特判。<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/echo.c</span></span><br><span class="line"><span class="keyword">if</span> (argv[i][<span class="number">0</span>] == <span class="string">&#x27;$&#x27;</span>) &#123;</span><br><span class="line">    <span class="type">char</span> key[<span class="number">128</span>], value[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; argv[i][j]; j++) &#123;</span><br><span class="line">        key[j<span class="number">-1</span>] = argv[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    key[j<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> ((r = syscall_get_env_var(key, value)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;get environment variable fail!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, value);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="二、额外实现的功能"><a href="#二、额外实现的功能" class="headerlink" title="二、额外实现的功能"></a>二、额外实现的功能</h2><h4 id="2-1-strcat"><a href="#2-1-strcat" class="headerlink" title="2.1 strcat"></a>2.1 strcat</h4><p>strcat是c语言标准库中string.h的一个重要函数，也是Lab6挑战性任务中我用的最多的函数。但是我们的string.h居然没有这个函数，所以我做的第一项任务就是把这个空缺给弥补上。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *tmp = dest;</span><br><span class="line">    <span class="keyword">while</span> (*dest)</span><br><span class="line">        dest++;</span><br><span class="line">        <span class="keyword">while</span> ((*dest++ = *src++) != <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="2-2-rm指令"><a href="#2-2-rm指令" class="headerlink" title="2.2 rm指令"></a>2.2 rm指令</h4><p>rm指令也是shell命令中非常重要的指令，而且我们的实验代码中已经实现了remove的用户接口，只需要调用一下并且实现一些关键的选项即可。我一共实现了三种选项：分别为-r、-i和-f，分别为递归删除、删除前询问以及强制删除。代码如下所示。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> flag[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">is_dir</span><span class="params">(<span class="type">int</span> fd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> ((r = get_type(fd)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;cannot find the file!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r == FTYPE_DIR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">query</span><span class="params">(<span class="type">char</span> *path)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> (flag[<span class="string">&#x27;i&#x27;</span>]) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;delete the file?: %s [y/n] &quot;</span>, path);</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        <span class="keyword">if</span> ((r = read(<span class="number">0</span>, &amp;c, <span class="number">1</span>)) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                debugf(<span class="string">&quot;read error: %d\n&quot;</span>, r);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">exit</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="string">&#x27;y&#x27;</span> &amp;&amp; c != <span class="string">&#x27;Y&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rm</span><span class="params">(<span class="type">char</span> *path)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r, fd, n;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">f</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(path, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;no such file or directory!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((r = get_type(fd)) == FTYPE_DIR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag[<span class="string">&#x27;r&#x27;</span>]) &#123;</span><br><span class="line">            <span class="keyword">while</span> ((n = readn(fd, &amp;f, <span class="keyword">sizeof</span> f)) == <span class="keyword">sizeof</span> f) &#123;</span><br><span class="line">                <span class="type">char</span> new_path[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="built_in">strcpy</span>(new_path, path);</span><br><span class="line">                <span class="keyword">if</span> (f.f_name[<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="built_in">strcat</span>(new_path, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">                    <span class="built_in">strcat</span>(new_path, f.f_name);</span><br><span class="line">                    <span class="keyword">if</span> (f.f_type == FTYPE_REG) &#123;</span><br><span class="line">                        query(new_path);</span><br><span class="line">                        remove(new_path);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        rm(new_path);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            query(path);</span><br><span class="line">            remove(path);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            user_panic(<span class="string">&quot;cannot remove: it is a directory&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        query(path);</span><br><span class="line">        remove(path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">usage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usage: rm [-选项] [file...]\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">	ARGBEGIN &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">        flag[(u_char)ARGC()]++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        usage();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ARGEND</span><br><span class="line">    <span class="title function_">for</span> <span class="params">(<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++)</span> &#123;</span><br><span class="line">        <span class="type">char</span> *path = parse_path(argv[i]);</span><br><span class="line">        rm(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="2-3"><a href="#2-3" class="headerlink" title="2.3 &gt;&gt;"></a>2.3 &gt;&gt;</h4><p>我们的mos目前可以支持重定向，但还不能支持追加重定向。&gt;&gt; 的实现整体上可参考&gt; 的实现，同样也是需要用到seek来锁定文件末尾，随后把标准输出复制到目标文件里，并且也是支持当文件不存在时就新建一个。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/sh.c</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;&gt;&gt;&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> (gettoken(<span class="number">0</span>, &amp;t) != <span class="string">&#x27;w&#x27;</span>) &#123;</span><br><span class="line">        debugf(<span class="string">&quot;syntax error: &gt;&gt; not followed by word\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(t, O_WRONLY | O_CREAT)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;open fail!&quot;</span>);</span><br><span class="line">    &#125;      </span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">if</span> ((size = get_size(fd)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;get size fail!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((r = seek(fd, size))) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;seek fail!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((r = dup(fd, <span class="number">1</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;dup fail!&quot;</span>);</span><br><span class="line">    &#125;       </span><br><span class="line">    <span class="keyword">if</span> ((r = close(fd)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;close fail!&quot;</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></div>
<h4 id="2-4-实现自动补全"><a href="#2-4-实现自动补全" class="headerlink" title="2.4 实现自动补全"></a>2.4 实现自动补全</h4><p>实现思路：当读入到tab键时，比较当前这段字符串是否是当前所有支持的命令的前缀，再比较该字符串是否是当前目录下文件的前缀。当找到唯一一个可补全的字符串时可以补全，其余情况不做处理。</p>
<h4 id="2-5-实现cp指令"><a href="#2-5-实现cp指令" class="headerlink" title="2.5 实现cp指令"></a>2.5 实现cp指令</h4><p>实现思路：与rm类似，分为-r、-i选项，分别为递归复制，覆盖前询问。复制的本质是将来源文件的内容读出，并写入目标文件。注意赋值时从来源文件读的字符数组与目标文件写的字符数组不能是同一个，否则只能达成“浅拷贝”的效果。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/cp.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">copy</span><span class="params">(<span class="type">int</span> srcfd, <span class="type">int</span> dstfd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="type">char</span> text[<span class="number">128</span> * <span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> new_text[<span class="number">128</span> * <span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> ((r = read(srcfd, text, <span class="keyword">sizeof</span> text)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;cannot read the file&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(new_text, text);</span><br><span class="line">    <span class="keyword">if</span> ((r = write(dstfd, new_text, <span class="keyword">sizeof</span> text)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;cannot write the file&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="三、实验结果"><a href="#三、实验结果" class="headerlink" title="三、实验结果"></a>三、实验结果</h2><h4 id="3-1-实现一行多命令-实现引号支持-实现程序名称中-b-的省略"><a href="#3-1-实现一行多命令-实现引号支持-实现程序名称中-b-的省略" class="headerlink" title="3.1 实现一行多命令 + 实现引号支持 + 实现程序名称中 .b 的省略"></a>3.1 实现一行多命令 + 实现引号支持 + 实现程序名称中 .b 的省略</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/os-lab6-challenge/1.png"
                      alt="1"
                ></p>
<h4 id="3-2-实现后台任务"><a href="#3-2-实现后台任务" class="headerlink" title="3.2 实现后台任务"></a>3.2 实现后台任务</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/os-lab6-challenge/12.png"
                      alt="12"
                ></p>
<h4 id="3-3-实现键入命令时任意位置的修改"><a href="#3-3-实现键入命令时任意位置的修改" class="headerlink" title="3.3 实现键入命令时任意位置的修改"></a>3.3 实现键入命令时任意位置的修改</h4><p>该任务适宜实时展现效果，难以通过图片形式看出效果</p>
<h4 id="3-4-实现更多命令（tree-mkdir-touch）"><a href="#3-4-实现更多命令（tree-mkdir-touch）" class="headerlink" title="3.4 实现更多命令（tree mkdir touch）"></a>3.4 实现更多命令（tree mkdir touch）</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/os-lab6-challenge/2.png"
                      alt="2"
                ></p>
<h4 id="3-5-实现历史命令功能"><a href="#3-5-实现历史命令功能" class="headerlink" title="3.5 实现历史命令功能"></a>3.5 实现历史命令功能</h4><p>上下键的功能不便以图片形式展示，此处只展现history指令<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/os-lab6-challenge/3.png"
                      alt="3"
                ></p>
<h4 id="3-6-支持相对路径"><a href="#3-6-支持相对路径" class="headerlink" title="3.6 支持相对路径"></a>3.6 支持相对路径</h4><p>为了更贴近linux，我将指令左侧改为了学号+相对路径的形式，与跳板机的格式相同。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/os-lab6-challenge/4.png"
                      alt="4"
                ></p>
<h4 id="3-7-实现-shell-环境变量"><a href="#3-7-实现-shell-环境变量" class="headerlink" title="3.7 实现 shell 环境变量"></a>3.7 实现 shell 环境变量</h4><p>依次先后测试了：不同类型环境变量的创建、删除非只读变量、删除只读变量、修改只读变量、修改非只读变量、启动子shell后能否读取局部变量。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/os-lab6-challenge/5.png"
                      alt="5"
                ></p>
<h4 id="3-8-实现rm"><a href="#3-8-实现rm" class="headerlink" title="3.8 实现rm"></a>3.8 实现rm</h4><ul>
<li>删除普通文件<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/os-lab6-challenge/9.png"
                      alt="9"
                ></li>
<li>递归删除目录<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/os-lab6-challenge/10.jpeg"
                      alt="10"
                ></li>
<li>删除前询问<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/os-lab6-challenge/8.png"
                      alt="8"
                ></li>
</ul>
<h3 id="3-9-实现"><a href="#3-9-实现" class="headerlink" title="3.9 实现&gt;&gt;"></a>3.9 实现&gt;&gt;</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/os-lab6-challenge/11.png"
                      alt="11"
                ></p>
<h2 id="四、实验难点及解决方案"><a href="#四、实验难点及解决方案" class="headerlink" title="四、实验难点及解决方案"></a>四、实验难点及解决方案</h2><h4 id="4-1-控制台输入部分与程序实际接收到的指令的协同"><a href="#4-1-控制台输入部分与程序实际接收到的指令的协同" class="headerlink" title="4.1 控制台输入部分与程序实际接收到的指令的协同"></a>4.1 控制台输入部分与程序实际接收到的指令的协同</h4><p>&emsp;&emsp;在user&#x2F;sh.c的readline函数中，我们的代码用的是一个名为buf的字符数组读取的输入。而如果没有引入移动光标的功能，我们可以直接向runcmd中传入这一数组进行解析。但现在引入了光标的移动，buf会读入方向键的ascii码，并且所有字符也都是顺序读入的，显然是无法直接解析的。所以我选择了将这个buf仅作为读入字符使用，实际的指令部分新建一个名为cmd的字符数组，所有更改都对cmd进行更改。</p>
<h4 id="4-2-如何掌握光标的位置"><a href="#4-2-如何掌握光标的位置" class="headerlink" title="4.2 如何掌握光标的位置"></a>4.2 如何掌握光标的位置</h4><p>&emsp;&emsp;事实上，我们始终都需要保证控制台输入、程序接收到的指令与控制台输出三者保持完全一致，而后两者的一致性可以靠连续输出三个字符来完成，如输出一个下键可以通过<code>printf(&quot;%c%c%c&quot;, 27, 91, 66)</code>这条语句来实现。以此类推，我们可以通过ascii码来实现控制台中光标的随意移动。</p>
<h4 id="4-3-修改fd-c，使得用户可以更方便的得知文件的一些基本属性。"><a href="#4-3-修改fd-c，使得用户可以更方便的得知文件的一些基本属性。" class="headerlink" title="4.3 修改fd.c，使得用户可以更方便的得知文件的一些基本属性。"></a>4.3 修改fd.c，使得用户可以更方便的得知文件的一些基本属性。</h4><p>&emsp;&emsp;在实现指令的过程中，我们经常需要得知文件的一些基本属性，如文件的名字、大小、种类等等，所以我们需要像面向对象一样，为文件写一些get方法，我是在fd.c实现的，可以通过fdnum就获得文件的大小、种类。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/lib/fd.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_size</span><span class="params">(<span class="type">int</span> fdnum)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">ffd</span>;</span></span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    ffd = (<span class="keyword">struct</span> Filefd *)fd;</span><br><span class="line">    <span class="type">int</span> size = ffd-&gt;f_file.f_size;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_type</span><span class="params">(<span class="type">int</span> fdnum)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">ffd</span>;</span></span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    ffd = (<span class="keyword">struct</span> FileFd *)fd;</span><br><span class="line">    <span class="type">int</span> type = ffd-&gt;f_file.f_type;</span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="4-4-让所有指令都支持相对路径（"><a href="#4-4-让所有指令都支持相对路径（" class="headerlink" title="4.4 让所有指令都支持相对路径（.&#x2F;..)"></a>4.4 让所有指令都支持相对路径（.&#x2F;..)</h4><p>为了向真实的linux靠拢，我还实现了..（上级目录）与.（当前目录），为了在所有文件中都能实现相对路径，我在user&#x2F;lib里新建了一个path.c文件用于解析路径。代码如下所示。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">parse_path</span><span class="params">(<span class="type">char</span> *path)</span> &#123;</span><br><span class="line">    <span class="type">char</span> cur_path[MAXPATHLEN] = &#123;<span class="number">0</span>&#125;; </span><br><span class="line">    <span class="type">char</span> tmp_path[MAXPATHLEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> new_path[MAXPATHLEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">strcpy</span>(cur_path, syscall_get_cur_path());</span><br><span class="line">    <span class="keyword">if</span> (path[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span>) &#123;	<span class="comment">//传进来的是相对路径</span></span><br><span class="line">    	<span class="keyword">if</span> (cur_path[<span class="built_in">strlen</span>(cur_path) - <span class="number">1</span>] != <span class="string">&#x27;/&#x27;</span>) &#123;s</span><br><span class="line">    	    <span class="title function_">strcpy</span><span class="params">(tmp_path, cur_path)</span>;</span><br><span class="line">    	    <span class="built_in">strcat</span>(tmp_path, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">    	    <span class="built_in">strcat</span>(tmp_path, path);</span><br><span class="line">    	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	    <span class="built_in">strcpy</span>(tmp_path, cur_path);</span><br><span class="line">    	    <span class="built_in">strcat</span>(tmp_path, path);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="built_in">strcpy</span>(tmp_path, path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> files[<span class="number">128</span>][<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> new_files[<span class="number">128</span>][<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> tmp_file[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;	<span class="comment">//指针</span></span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span>, file_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> tmp_path_len = <span class="built_in">strlen</span>(tmp_path);</span><br><span class="line">    <span class="keyword">if</span> (tmp_path[tmp_path_len - <span class="number">1</span>] != <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">    	tmp_path[tmp_path_len] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    	tmp_path[tmp_path_len + <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; tmp_path[i]; i++) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (tmp_path[i] != <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">    	    tmp_file[length++] = tmp_path[i];</span><br><span class="line">    	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	    tmp_file[length] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    	    <span class="built_in">strcpy</span>(files[file_cnt++], tmp_file);</span><br><span class="line">    	    <span class="built_in">memset</span>(tmp_file, <span class="number">0</span>, <span class="keyword">sizeof</span>(tmp_file));</span><br><span class="line">    	    length = <span class="number">0</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; file_cnt; i++) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(files[i], <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    	    p--;</span><br><span class="line">    	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(files[i], <span class="string">&quot;.&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    	    <span class="keyword">continue</span>;</span><br><span class="line">    	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	    <span class="built_in">memset</span>(new_files[p], <span class="number">0</span>, <span class="keyword">sizeof</span>(new_files[p]));</span><br><span class="line">    	    <span class="built_in">strcpy</span>(new_files[p++], files[i]);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    new_path[<span class="number">0</span>] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; p; i++) &#123;</span><br><span class="line">    	<span class="built_in">strcat</span>(new_path, new_files[i]);</span><br><span class="line">    	<span class="keyword">if</span> (i != p - <span class="number">1</span>) &#123;</span><br><span class="line">    	    <span class="built_in">strcat</span>(new_path, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> *pointer = new_path;</span><br><span class="line">    <span class="keyword">return</span> pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="五、实验体会"><a href="#五、实验体会" class="headerlink" title="五、实验体会"></a>五、实验体会</h2><p>&emsp;&emsp;挑战性任务的实验难度无疑是比任何一个Lab的难度都要高的，它考验的是你对于这些代码综合运用的能力，比之前的完形填空高到不知哪里去了。我在Lab6挑战性任务也是深有体会，此前偷懒没看的代码在挑战性任务里都会一一偿还的。诚然挑战性任务的确很难，但一点一点去完成实现的过程也是非常快乐并且富有满足感。尤其是当你选了Lab6这样效果非常直观的挑战性任务，看到属于自己的mos不断完善，并逐渐强大，就觉得所有的努力都是值得的。<br>&emsp;&emsp;回顾一学期操作系统的学习，我想对我提升最大的除了对于操作系统的理解，就是对于c语言的掌握程度了。学习过操作系统以后我对c语言的了解程度可以说是比大一上完程设、数据结构又更上一层楼。在完成Lab6的过程中，我和伙伴曾经仅仅对于指针的一个小问题就探讨了两个小时，并且还写了很多的测试小程序用来探究原理。我想这些方面对我的提升是最关键的，或许若干年后我会忘记操作系统的知识、会忘记c语言的机制，但是遇到问题去写一个测试程序验证的这种精神与方法是可以伴随我很长时间的。这就是这门课带给我的最大的提升。</p>
]]></content>
      <categories>
        <category>专业课</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>OS</tag>
        <tag>实验报告</tag>
      </tags>
  </entry>
  <entry>
    <title>OS-Lab6 实验报告</title>
    <url>/2024/08/18/OS-Lab6-Experiment-Report/</url>
    <content><![CDATA[<h1 id="Lab6实验报告"><a href="#Lab6实验报告" class="headerlink" title="Lab6实验报告"></a>Lab6实验报告</h1><h2 id="一、思考题"><a href="#一、思考题" class="headerlink" title="一、思考题"></a>一、思考题</h2><h3 id="Thinking6-1"><a href="#Thinking6-1" class="headerlink" title="Thinking6.1"></a>Thinking6.1</h3><p><strong>Q：示例代码中，父进程操作管道的写端，子进程操作管道的读端。如果现在想 让父进程作为“读者”，代码应当如何修改？</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> fildes[<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> buf[<span class="number">100</span>]; <span class="type">int</span> status;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    status = pipe(fildes);</span><br><span class="line"><span class="keyword">if</span> (status == <span class="number">-1</span> ) &#123; <span class="built_in">printf</span>(<span class="string">&quot;error\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> (fork()) &#123; </span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 子进程 - 作为管道的写者 */</span> </span><br><span class="line">        close(fildes[<span class="number">0</span>]);</span><br><span class="line">        write(fildes[<span class="number">1</span>], <span class="string">&quot;Hello world\n&quot;</span>, <span class="number">12</span>); </span><br><span class="line">        close(fildes[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* 父进程 - 作为管道的读者 */</span> </span><br><span class="line">        close(fildes[<span class="number">1</span>]);</span><br><span class="line">        read(fildes[<span class="number">0</span>], buf, <span class="number">100</span>); </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;father-process read:%s&quot;</span>,buf); </span><br><span class="line">        close(fildes[<span class="number">0</span>]); </span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>修改后的代码如上图所示</p>
<h3 id="Thinking6-2"><a href="#Thinking6-2" class="headerlink" title="Thinking6.2"></a>Thinking6.2</h3><p><strong>Q：上面这种不同步修改 pp_ref 而导致的进程竞争问题在 user&#x2F;lib&#x2F;fd.c 中 的 dup 函数中也存在。请结合代码模仿上述情景，分析一下我们的 dup 函数中为什么会出 现预想之外的情况?</strong><br><strong>A：</strong> dup函数的作用是将一个文件描述符复制给另一个，以此实现文件的复制。dup函数的实现步骤是先将newfd所在的虚拟页映射到oldfd所在的物理页，再将newfd的数据所在的虚拟页映射到oldfd的数据所在的物理页。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子进程</span></span><br><span class="line">    read(p[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="comment">// 父进程    </span></span><br><span class="line">    dup(p[<span class="number">0</span>], newfd);</span><br><span class="line">    write(p[<span class="number">1</span>], <span class="string">&quot;Hello&quot;</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure></div>
<p>在以上示例中，子进程先进行，若read之前发生中断，切换到父进程，若此时dup和write之间发生中断，父进程执行完dup以后没来得及往管道里写东西。切换回子进程，执行read函数，发现pageref(p[0]) &#x3D;&#x3D; pageref(pipe) &#x3D;&#x3D; 2，误认为通道关闭，发生了错误。</p>
<h3 id="Thinking6-3"><a href="#Thinking6-3" class="headerlink" title="Thinking6.3"></a>Thinking6.3</h3><p><strong>Q：阅读上述材料并思考:为什么系统调用一定是原子操作呢?如果你觉得不是 所有的系统调用都是原子操作，请给出反例。希望能结合相关代码进行分析说明。</strong><br><strong>A：</strong> 在mos的实现中，我没有找到关闭中断的代码，但是进入内核态确实是需要关闭中断的，想必应该是交给硬件实现了，既然关闭了中断那么就必然是原子操作。但是沃天宇老师也说过，系统调用未必都是原子操作。在mos以外的操作系统中应该还有别的方式打断系统调用。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/os-lab6/1.jpeg"
                      alt="1"
                ></p>
<h3 id="Thinking6-4"><a href="#Thinking6-4" class="headerlink" title="Thinking6.4"></a>Thinking6.4</h3><p><strong>Q：仔细阅读上面这段话，并思考下列问题<br>• 按照上述说法控制pipe_close中fd和pipeunmap的顺序，是否可以解决上述场<br>    景的进程竞争问题?给出你的分析过程。<br>• 我们只分析了close时的情形，在fd.c中有一个dup函数，用于复制文件描述符。 试想，如果要复制的文件描述符指向一个管道，那么是否会出现与 close 类似的问 题?请模仿上述材料写写你的理解。</strong><br><strong>A：</strong></p>
<ul>
<li>可以解决。因为本来pageref(p[0])就要小于pageref(pipe)，所以先解除p[0]的映射就会让pageref(p[0])更小，也就更加保证了不会出现pageref(p[0]) &#x3D;&#x3D; pageref(pipe)的情况。</li>
<li>会。dup与close类似，在dup中永远有pageref(pipe) &gt; pageref(p[0])，若先映射fd再映射pipe，同样会导致pageref(pipe) &#x3D;&#x3D; pageref(p[0])，会被误以为管道关闭，与close类似，我们同样也可以通过调换代码顺序的情况避免上述问题。先映射pipe，再映射fd，可以避免二者相等。</li>
</ul>
<h3 id="Thinking6-5"><a href="#Thinking6-5" class="headerlink" title="Thinking6.5"></a>Thinking6.5</h3><p><strong>Q：思考以下三个问题。<br>• 认真回看 Lab5 文件系统相关代码，弄清打开文件的过程。<br>• 回顾 Lab1 与 Lab3，思考如何读取并加载 ELF 文件。<br>• 在Lab1中我们介绍了datatextbss段及它们的含义，data段存放初始化过的全局变量，bss 段存放未初始化的全局变量。关于 memsize 和 filesize ，我们在 Note 1.3.4中也解释了它们的含义与特点。关于 Note 1.3.4，注意其中关于“bss 段并不在文件中占数据”表述的含义。回顾 Lab3 并思考:elf_load_seg() 和 load_icode_mapper() 函数是如何确保加载 ELF 文件时，bss 段数据被正确加载进虚拟内存空间。bss 段 在 ELF 中并不占空间，但 ELF 加载进内存后，bss 段的数据占据了空间，并且初始值都是 0。请回顾 elf_load_seg() 和 load_icode_mapper() 的实现，思考这一点是如何实现的?</strong><br><strong>A：</strong></p>
<ul>
<li>前两问指导书已经给出解答，此处不过多赘述</li>
<li>在lib&#x2F;elfloader.c里，可以找到对应的映射函数，我们读到filesz和memsz，若memsz大于filesz，就在最后补上相应的0。如下图所示。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/os-lab6/5.png"
                      alt="5"
                ></li>
</ul>
<h3 id="Thinking6-6"><a href="#Thinking6-6" class="headerlink" title="Thinking6.6"></a>Thinking6.6</h3><p><strong>Q：通过阅读代码空白段的注释我们知道，将标准输入或输出定向到文件，需要 我们将其 dup 到 0 或 1 号文件描述符(fd)。那么问题来了:在哪步，0 和 1 被“安排”为 标准输入和标准输出?请分析代码执行流程，给出答案。</strong><br><strong>A：</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/os-lab6/2.png"
                      alt="2"
                ><br>在user&#x2F;init.c中，设置了标准输入输出。</p>
<h3 id="Thinking6-7"><a href="#Thinking6-7" class="headerlink" title="Thinking6.7"></a>Thinking6.7</h3><p><strong>Q：在shell 中执行的命令分为内置命令和外部命令。在执行内置命令时 shell 不 需要 fork 一个子 shell，如 Linux 系统中的 cd 命令。在执行外部命令时 shell 需要 fork 一个子 shell，然后子 shell 去执行这条命令。<br>据此判断，在 MOS 中我们用到的 shell 命令是内置命令还是外部命令?请思考为什么 Linux 的 cd 命令是内部命令而不是外部命令?</strong><br><strong>A：</strong></p>
<ul>
<li>我们的mos中用到的shell命令是外部命令，因为每次我们执行一个命令都要fork出一个新进程，这个子shell再调用spawn函数执行命令。</li>
<li>linux的内部命令包含在shell程序里面，内部命令不需要使用子进程来执行，它们已经和shell编译成一体，作为shell工具的组成部分存在。内部命令包含一些比较简单的linux系统命令。而cd命令操作简单，并且执行次数非常多，把它放进shell程序里，而不是靠创建子进程执行，可以大大提高系统的效率。</li>
</ul>
<h3 id="Thinking6-8"><a href="#Thinking6-8" class="headerlink" title="Thinking6.8"></a>Thinking6.8</h3><p><strong>Q：在你的 shell 中输入命令 ls.b | cat.b &gt; motd。<br>• 请问你可以在你的 shell 中观察到几次 spawn ?分别对应哪个进程?<br>• 请问你可以在你的 shell 中观察到几次进程销毁?分别对应哪个进程?</strong><br><strong>A：</strong></p>
<ul>
<li>shell中执行了两次spawn，分别对应ls和cat。</li>
<li>同样，shell执行了两次进程销毁，分别对应ls和cat。</li>
</ul>
<h2 id="二、实验难点"><a href="#二、实验难点" class="headerlink" title="二、实验难点"></a>二、实验难点</h2><p>1、实现管道的读，例如下示代码。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/os-lab6/3.png"
                      alt="3"
                ><br>2、理解管道之间由于进程切换导致的竞争与同步问题。<br>3、综合运用之前lab的知识，如spawn就运用了lab3的elf_load_seg函数，如下图所示。<br>此外，理解spawn的流程也是个难点。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/os-lab6/4.png"
                      alt="4"
                ></p>
<h2 id="三、实验感想"><a href="#三、实验感想" class="headerlink" title="三、实验感想"></a>三、实验感想</h2><p>&emsp;&emsp;本次实验需要填的代码不是很多，但很考验综合运用能力，尤其是运用了很多关于elf的知识，较为复杂，有点像一个期末的综合考核。而且这次需要阅读的代码量依旧很大，还是花费了我很多时间的。<br>&emsp;&emsp;但是最后看到自己实现的mos可以完成一些基本的指令时还是很有成就感的，依旧是收获满满的一个lab！</p>
]]></content>
      <categories>
        <category>专业课</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>OS</tag>
        <tag>实验报告</tag>
      </tags>
  </entry>
  <entry>
    <title>Simon雅思写作网课笔记——小作文篇</title>
    <url>/2024/08/24/Simon-Writing-Task1-Note/</url>
    <content><![CDATA[<h1 id="Task-1-小作文"><a href="#Task-1-小作文" class="headerlink" title="Task 1 小作文"></a>Task 1 小作文</h1><h3 id="Lesson-1-Overview"><a href="#Lesson-1-Overview" class="headerlink" title="Lesson 1. Overview"></a>Lesson 1. Overview</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Remember: </span><br><span class="line">* No conclusion</span><br><span class="line">* Write a summary(the overview)</span><br></pre></td></tr></table></figure></div>

<p><strong>Question types:</strong></p>
<ol>
<li>Line graph</li>
<li>Bar chart</li>
<li>Pie chart</li>
<li>Table</li>
<li>Diagram - comparing</li>
<li>Diagram - process</li>
</ol>
<p><strong>4 paragraphs</strong></p>
<ol>
<li>Introduction<ol>
<li>1 sentence: Paraphrase the question</li>
</ol>
</li>
<li><strong>Overview</strong><ol>
<li>2 sentence: The main, general things</li>
<li>No specific numbers</li>
<li>Do not use “In conclusion”</li>
</ol>
</li>
<li>Details</li>
<li>Details<ol>
<li>Why 2 paragraphs? This makes you organise or group the information better.</li>
</ol>
</li>
</ol>
<p>No conclusion!</p>
<h3 id="Lesson-2-Line-Graph"><a href="#Lesson-2-Line-Graph" class="headerlink" title="Lesson 2. Line Graph"></a>Lesson 2. Line Graph</h3><ul>
<li>Usually 3 or 4 lines</li>
<li><strong>Compare</strong> the lines, not describe them seperately</li>
<li>Two type of Comparison:<ol>
<li>Make a very general comparison.(2nd paragraph)<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/1.png"
                     
                ><br>  e.g. The blue line is higher than the other line overall.</li>
<li>Compare the lines at specific points. (3rd and 4th)<br> <strong>Write at least one thing about each line.</strong></li>
</ol>
</li>
</ul>
<p>An example:<br>    <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/2.png"
                     
                ></p>
<ol>
<li>Introduction<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/3.png"
                     
                ><ul>
<li>electricity production -&gt; amount of electricity produced</li>
<li>题目如果没说几种可以加上</li>
<li>between 1980 and 2012 -&gt; over a period of 32 years</li>
</ul>
</li>
<li>Overview<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/4.png"
                     
                ><ul>
<li>注意这里没有直接说核能是最高的，而是说了核能是最重要的能源</li>
<li>找最大、最小的</li>
</ul>
</li>
<li>Paragraph 3<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/5.png"
                     
                ><ul>
<li>思路：从第一年开始，比较四条线；并找一个交叉点（较重要的点）<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/6.png"
                     
                ></li>
<li>Don’t just use the word you can take from the graph</li>
<li><strong>Be very careful of the subjects!</strong></li>
</ul>
</li>
<li>Paragraph 4<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/7.png"
                     
                > <ul>
<li>思路：每条线至少可以写一件事。</li>
<li>detail的两段把四条线都写了</li>
</ul>
</li>
</ol>
<ul>
<li><strong>Vocabulary</strong>:<ul>
<li>amount of electricity produced</li>
<li>source of &#x2F; provided &#x2F; generating</li>
<li>means of electricity generation</li>
<li>over a period of &#x2F; over the period shown</li>
<li>by far the most important(到目前为止最重要的)</li>
<li>a <strong>negligible</strong> amount</li>
<li>nuclear power <strong>overtook</strong> thermal power</li>
<li>as the <strong>primary</strong> source of electricity</li>
<li>rose dramatically to a peak of</li>
<li>by contrast</li>
<li>the figure for(…的数据)</li>
<li>remained at this level, remained <strong>stable</strong></li>
<li><strong>saw</strong> only a small rise</li>
</ul>
</li>
</ul>
<h3 id="Lesson-3-Bar-Chart"><a href="#Lesson-3-Bar-Chart" class="headerlink" title="Lesson 3. Bar Chart"></a>Lesson 3. Bar Chart</h3><p>Your job is to compare the bars.</p>
<ol>
<li>Make a very general comparison. (2nd paragraph)</li>
<li>Compare specific numbers.</li>
</ol>
<p>An example:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/8.png"
                     
                ></p>
<ol>
<li>Introduction<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/9.png"
                     
                ><ul>
<li>shows -&gt; compares</li>
<li>sales -&gt; sold worldwide</li>
<li>top five mobile phone brands -&gt; five most popular manufacturers</li>
<li>between 2009 and 2003 -&gt; in the years of 2009, 2011 and 2013</li>
</ul>
</li>
<li>Overview<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/10.png"
                     
                ><ul>
<li>两个方面：横向 &amp; 纵向</li>
</ul>
</li>
<li>Paragraph 3<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/11.png"
                     
                ><ul>
<li><strong>Group</strong>: 第三段写三星和诺基亚（销量最高的两个），第四段写其他。</li>
<li><strong>Languages</strong>:<ul>
<li>Compariosns: <ul>
<li>almost double</li>
<li>second most successful</li>
<li>whereas</li>
<li>had become the market leader</li>
</ul>
</li>
<li>Changes over time:<ul>
<li>Over the following 4 years</li>
<li>sales figures fell by approximately 200 million units</li>
<li>saw sales rise by a similar amount</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Paragraph 4<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/12.png"
                     
                ><ul>
<li><strong>Languages</strong>:<ul>
<li>Comparisons<ul>
<li>these companies sold…respectively</li>
<li>Apple overtook the other two</li>
<li>while…and</li>
</ul>
</li>
<li>Changes over time<ul>
<li>purchases of Apple handsets reached</li>
<li>LG saw declining sales</li>
<li>figures for ZTE rose only slightly</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>Vocabulary:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/13.png"
                     
                ></li>
</ul>
<h3 id="Lesson-4-Pie-Chart"><a href="#Lesson-4-Pie-Chart" class="headerlink" title="Lesson 4. Pie Chart"></a>Lesson 4. Pie Chart</h3><ol>
<li>Make a very general comparison. (2nd paragraph)</li>
<li>Compare specific numbers.</li>
</ol>
<p><strong>An example:</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/14.png"
                     
                ></p>
<ol>
<li>Introduction<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/15.png"
                     
                ><ul>
<li>five categories</li>
<li>spending -&gt; expenditure</li>
<li>in two contries -&gt; in UK and New Zealand</li>
<li>between 1980 and 2008 -&gt; in the year of 2008</li>
</ul>
</li>
<li>Overview<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/16.png"
                     
                ><ul>
<li><strong>counterparts</strong>: 对应的事物</li>
</ul>
</li>
<li>Paragraph 3<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/17.png"
                     
                ><ul>
<li>The same information as the overview, but in more detail(Doesn’t always work)</li>
</ul>
</li>
<li>Paragraph 4<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/18.png"
                     
                ></li>
</ol>
<p><strong>Tips</strong>:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/19.png"
                     
                ></p>
<ul>
<li>不要写成第3段一个国家&#x2F;年份，第四段另一个的形式</li>
<li>Other不重要不是因为最少，而是本身就不重要</li>
</ul>
<p><strong>Vocabulary</strong>:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/20.png"
                     
                ></p>
<ul>
<li><strong>by + time : past perfect</strong></li>
</ul>
<h3 id="Lesson-5-Table"><a href="#Lesson-5-Table" class="headerlink" title="Lesson 5. Table"></a>Lesson 5. Table</h3><p>Your job is to <strong>select</strong>, compare and describe the key numbers</p>
<p>An example:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/21.png"
                     
                ></p>
<ol>
<li>Introduction<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/22.png"
                     
                ></li>
<li>Overview<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/23.png"
                     
                ><ul>
<li>revenue: 收入</li>
</ul>
</li>
<li>Details 1<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/24.png"
                     
                ><ul>
<li>totally about number of tourists</li>
<li>all five contries are mentioned</li>
<li>start from the highest</li>
</ul>
</li>
<li>Details 2<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/25.png"
                     
                ><ul>
<li>last sentence is nice because it links 3rd and 4th paragraph</li>
<li>structure: 1 big sentence about the highest, 1 sentence about the other, 1 sentence is link</li>
</ul>
</li>
</ol>
<ul>
<li>Select 6-10 figures</li>
<li><strong>Vacabulary:</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/26.png"
                     
                ><ul>
<li>4 word is enough: rise, fall, increase, decrease</li>
</ul>
</li>
</ul>
<h3 id="Lesson-6-2-Different-Chart"><a href="#Lesson-6-2-Different-Chart" class="headerlink" title="Lesson 6. 2 Different Chart"></a>Lesson 6. 2 Different Chart</h3><p>Your job is to <strong>select</strong>, compare and describe the key numbers</p>
<p>But you don’t need to compare the 2 charts together - <strong>you can describe them separately.</strong></p>
<ol>
<li>First, Look for one main feature in <strong>each</strong> chart (1 and 2 paragraphs)</li>
<li>Second, describe specific numbers for each chart <strong>seperately</strong> (details paragraphs)</li>
</ol>
<p>An example:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/27.png"
                     
                ></p>
<ol>
<li>Introduction<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/28.png"
                     
                ><ul>
<li>适当去掉没有用的信息</li>
<li>men and women -&gt; males and females</li>
<li>various -&gt; four different</li>
<li>courses -&gt; classes</li>
<li>information about the ages -&gt; age profile</li>
<li>participants -&gt; attendees</li>
</ul>
</li>
<li>Overview<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/29.png"
                     
                ></li>
<li>Details 1<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/30.png"
                     
                ><ul>
<li>First, “according to the bar chart” means this paragraph is about bar chart</li>
<li>more women than men -&gt; both genders -&gt; more men than women </li>
<li>mention specific number (not too much)</li>
<li>Adding numbers: <strong>“, with”</strong>, <strong>“, attracting”</strong></li>
</ul>
</li>
<li>Details 2<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/31.png"
                     
                ><ul>
<li>Adding numbers: <strong>“To be precise, “</strong></li>
</ul>
</li>
</ol>
<ul>
<li><strong>Vacabulary:</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/32.png"
                     
                ></li>
</ul>
<h3 id="Lesson-7-Process-diagram"><a href="#Lesson-7-Process-diagram" class="headerlink" title="Lesson 7. Process diagram"></a>Lesson 7. Process diagram</h3><ul>
<li><p>Describing a process is completely different from describing a graph, bar chart, pie chart or table</p>
</li>
<li><p>Differences:</p>
<ul>
<li>no numbers</li>
<li>can’t compare anything</li>
<li>can’t describe trends</li>
</ul>
</li>
<li><p>What can we describe?</p>
<ul>
<li>how many steps</li>
<li>where the process begins and ends</li>
<li>each step in the process</li>
</ul>
</li>
<li><p>Language for process descriptions:</p>
<ul>
<li>‘steps’ language<ul>
<li>At the first stage in the process</li>
<li>The process begins with</li>
<li>Secondly, Finally</li>
<li>The second step involves</li>
<li>Next, then, after that</li>
<li>At the following stage</li>
</ul>
</li>
<li>passive verbs</li>
</ul>
</li>
<li><p>An example<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/33.png"
                     
                ></p>
</li>
</ul>
<ol>
<li>Introduction<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/34.png"
                     
                ><ul>
<li>describe seperately</li>
<li>diagrams -&gt; first&#x2F;second flow diagram</li>
</ul>
</li>
<li>Overview<ul>
<li>Select information<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/35.png"
                     
                ></li>
<li>和之前不一样：写原材料、分别有几个步骤<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/36.png"
                     
                ></li>
</ul>
</li>
<li>Details 1<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/37.png"
                     
                ></li>
<li>Details 2<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/38.png"
                     
                ></li>
</ol>
<ul>
<li><strong>Vocabulary:</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/39.png"
                     
                ></li>
</ul>
<h3 id="Lesson-8-Comparison-diagrams"><a href="#Lesson-8-Comparison-diagrams" class="headerlink" title="Lesson 8. Comparison diagrams"></a>Lesson 8. Comparison diagrams</h3><ul>
<li><p>Your job is to compare the diagrams:</p>
<ul>
<li>Describe the changes</li>
<li>Describe things don’t change</li>
<li>Describe the differences</li>
<li>Describe the similarities</li>
</ul>
</li>
<li><p>Pay attention to <strong>Verb Tense</strong></p>
</li>
<li><p>An example:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/40.png"
                     
                ></p>
</li>
</ul>
<ol>
<li>Introduction<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/41.png"
                     
                ><ul>
<li>diagrams -&gt; two pictures</li>
<li>existing ground floor plan -&gt; current layout</li>
<li>some building work -&gt; redesign the same living space</li>
</ul>
</li>
<li>Overview<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/42.png"
                     
                ><ul>
<li>要点: 选变量和不变量</li>
</ul>
</li>
<li>Details 1<br> 不要第3段写第一幅图，第4段写另一幅。体现出对比，分数更高。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/46.png"
                     
                ><br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/43.png"
                     
                ></li>
<li>Details 2<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/47.png"
                     
                ><br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/44.png"
                     
                ></li>
</ol>
<ul>
<li><strong>Vocabulary:</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/goldenkm/Pic-Bed@main/simon-writing-task1/45.png"
                     
                ></li>
</ul>
]]></content>
      <categories>
        <category>课外内容</category>
      </categories>
      <tags>
        <tag>留学</tag>
        <tag>上岸</tag>
        <tag>IELTS</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库期末知识点总结</title>
    <url>/2024/08/24/Database-KnowLedge/</url>
    <content><![CDATA[<h1 id="数据库背诵知识点"><a href="#数据库背诵知识点" class="headerlink" title="数据库背诵知识点"></a>数据库背诵知识点</h1><hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>众所周知，数据库是一个<del>文科课程</del>，期末的题型也比较固定，就是比谁背的牢。以下是<strong>本人</strong>速通期末总结的知识点，<strong>非官方出品</strong>。感觉总结的还是挺全的，最后笔试不行完全是本人背的不好，放博客上留个纪念～</p>
<h2 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h2><h3 id="1-1-数据库管理技术发展的三个阶段"><a href="#1-1-数据库管理技术发展的三个阶段" class="headerlink" title="1.1 数据库管理技术发展的三个阶段"></a>1.1 数据库管理技术发展的三个阶段</h3><p>人工管理阶段、文件系统阶段、数据库系统阶段</p>
<h4 id="1-1-1-文件系统的特点与缺点"><a href="#1-1-1-文件系统的特点与缺点" class="headerlink" title="1.1.1 文件系统的特点与缺点"></a>1.1.1 文件系统的特点与缺点</h4><p><strong>特点</strong>：</p>
<ul>
<li>数据以文件形式保留在外存上</li>
<li>文件多样化</li>
<li>数据的存取基本上以记录为单位</li>
<li>程序和数据有一定的独立性</li>
<li>文件与应用程序基本上是一一对应，数据共享性差，冗余度大</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>文件分散、相互独立、数据冗余度大，数据和程序缺乏独立性</li>
<li>存储空间浪费</li>
<li>容易造成数据的不一致性</li>
<li>数据维护难度大</li>
<li>程序维护工作量大</li>
</ul>
<h4 id="1-1-2-数据库系统数据管理的特点"><a href="#1-1-2-数据库系统数据管理的特点" class="headerlink" title="1.1.2 数据库系统数据管理的特点"></a>1.1.2 数据库系统数据管理的特点</h4><ul>
<li>面向全组织的复杂的数据结构，数据结构化</li>
<li>数据冗余度小、易扩充</li>
<li>具有较高的数据和程序的独立性<ul>
<li>数据的物理独立性</li>
<li>数据的逻辑独立性</li>
<li>实现：三级模式两级映象</li>
</ul>
</li>
<li>统一的数据控制功能<ul>
<li>安全性控制</li>
<li>完整性控制</li>
<li>并发控制</li>
<li>数据库恢复</li>
</ul>
</li>
<li>数据的最小存取单位是数据项</li>
</ul>
<p>二者的本质区别：数据库系统实现整体数据的结构，而文件系统中数据之间是孤立的</p>
<h3 id="1-2-数据模型"><a href="#1-2-数据模型" class="headerlink" title="1.2 数据模型"></a>1.2 数据模型</h3><h4 id="1-2-1-概念模型的基本概念"><a href="#1-2-1-概念模型的基本概念" class="headerlink" title="1.2.1 概念模型的基本概念"></a>1.2.1 概念模型的基本概念</h4><p><strong>定义</strong>：概念模型基于信息世界的主要概念，表达应用中的各种语义。<br><strong>特点</strong>：具有较强的语义表达能力，能够方便、直接表达应用中的各种语义<br><strong>要求</strong>：应该清晰简单、易于理解<br><strong>常用方法</strong>：ER法<br><strong>名词解释</strong>：</p>
<ul>
<li>实体：客观存在并可相互区分的事物</li>
<li>属性：实体所具有的某一特性</li>
<li>码：唯一标识实体的属性集</li>
<li>域：某个（些）属性的取值范围</li>
<li>实体型：表示一类实体，用实体及其属性名集合来抽象、刻画。</li>
</ul>
<h4 id="1-2-2-数据模型"><a href="#1-2-2-数据模型" class="headerlink" title="1.2.2 数据模型"></a>1.2.2 数据模型</h4><h5 id="1-2-2-1-数据模型三要素（很重要）"><a href="#1-2-2-1-数据模型三要素（很重要）" class="headerlink" title="1.2.2.1 数据模型三要素（很重要）"></a>1.2.2.1 数据模型三要素（很重要）</h5><ul>
<li>数据结构：<ul>
<li>由描述数据对象以及对象之间联系的一组概念组成。</li>
<li>是数据静态特性的描述</li>
<li>是刻画数据模型最重要的方面</li>
</ul>
</li>
<li>数据操作<ul>
<li>是数据动态特性的描述</li>
<li>主要有检索和更新（增删改）两大类操作</li>
</ul>
</li>
<li>完整性约束</li>
</ul>
<h5 id="1-2-2-2-数据模型分类"><a href="#1-2-2-2-数据模型分类" class="headerlink" title="1.2.2.2 数据模型分类"></a>1.2.2.2 数据模型分类</h5><ul>
<li>层次模型：<ul>
<li>优点：结构简单、易于实现</li>
<li>缺点：支持的联系种类太少（只能直接表示二元一对关系），数据操纵不方便</li>
</ul>
</li>
<li>网状模型<ul>
<li>优点：表达的联系种类丰富（能直接表示多对多关系）</li>
<li>缺点：结构复杂</li>
</ul>
</li>
<li>关系模型<ul>
<li>数据结构简化，概念简单</li>
<li>可直接表示多对多联系</li>
<li>不允许表中套表</li>
<li>建立在数学概念基础上，有较强的理论基础</li>
</ul>
</li>
</ul>
<h3 id="1-3-数据库系统结构"><a href="#1-3-数据库系统结构" class="headerlink" title="1.3 数据库系统结构"></a>1.3 数据库系统结构</h3><h4 id="1-3-1-三级模式体系结构构成及其优点"><a href="#1-3-1-三级模式体系结构构成及其优点" class="headerlink" title="1.3.1 三级模式体系结构构成及其优点"></a>1.3.1 三级模式体系结构构成及其优点</h4><p><strong>构成</strong>：</p>
<ul>
<li>三级模式：模式、外模式、内模式</li>
<li>两级映象：外模式&#x2F;模式映象、模式&#x2F;内模式映象</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>保证数据的独立性</li>
<li>简化用户接口、方便用户使用</li>
<li>有利于数据共享</li>
<li>有利于数据的安全保密</li>
</ul>
<h4 id="1-3-2-数据独立性的概念"><a href="#1-3-2-数据独立性的概念" class="headerlink" title="1.3.2 数据独立性的概念"></a>1.3.2 数据独立性的概念</h4><p><strong>数据物理独立性</strong>：当内模式改变时，模式&#x2F;内模式映象做相应修改，使得模式保持不变<br><strong>数据逻辑独立性</strong>：当模式改变时，外模式&#x2F;模式映象做相应改变，可以保证外模式不变</p>
<h4 id="1-3-3-DBMS（Database-Management-System）"><a href="#1-3-3-DBMS（Database-Management-System）" class="headerlink" title="1.3.3 DBMS（Database Management System）"></a>1.3.3 DBMS（Database Management System）</h4><p><strong>主要功能</strong>：</p>
<ol>
<li>数据库定义功能</li>
<li>数据库运行管理</li>
<li>数据库的建立和维护功能</li>
<li>数据存取功能</li>
<li>数据组织、存储和管理</li>
</ol>
<p><strong>组成</strong>：</p>
<ol>
<li>语言编译处理程序</li>
<li>系统运行控制程序</li>
<li>系统建立和维护程序</li>
<li>数据字典<ul>
<li>也称为数据目录或系统目录，由一系列表组成，存储这数据库中有关信息的当前描述，包括数据库的三级模式、用户名表、用户权限等信息。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="第二章-关系数据库"><a href="#第二章-关系数据库" class="headerlink" title="第二章 关系数据库"></a>第二章 关系数据库</h2><h3 id="2-1-关系模型"><a href="#2-1-关系模型" class="headerlink" title="2.1 关系模型"></a>2.1 关系模型</h3><h4 id="2-1-1关系模型的数据结构"><a href="#2-1-1关系模型的数据结构" class="headerlink" title="2.1.1关系模型的数据结构"></a>2.1.1关系模型的数据结构</h4><h2 id="基本概念：-关系、域、n目关系、元组、属性-码-侯选码：某一属性组，唯一标识了一个元组，并且具有最小性-主码：若有多个候选码，选其中之一-主属性与非主属性-关系模式：R-U-D-dom-F-2-1-2-关系模型的完整性约束-实体完整性：主码不可为空-参照完整性：如果关系R的主码-F-k-与关系S的主码-P-k-相对应，则R中的每一个元组的-F-k-值或者等于S中的某个元组的-P-k-值，或者为空。-用户定义完整性-2-1-3-关系的性质-列是同质的-不同的列可出自同一域，每列必须有不同的属性名-列的顺序无关紧要-行的顺序无关紧要-任意两个元组不能完全相同-每一分量必须是不可再分的数据"><a href="#基本概念：-关系、域、n目关系、元组、属性-码-侯选码：某一属性组，唯一标识了一个元组，并且具有最小性-主码：若有多个候选码，选其中之一-主属性与非主属性-关系模式：R-U-D-dom-F-2-1-2-关系模型的完整性约束-实体完整性：主码不可为空-参照完整性：如果关系R的主码-F-k-与关系S的主码-P-k-相对应，则R中的每一个元组的-F-k-值或者等于S中的某个元组的-P-k-值，或者为空。-用户定义完整性-2-1-3-关系的性质-列是同质的-不同的列可出自同一域，每列必须有不同的属性名-列的顺序无关紧要-行的顺序无关紧要-任意两个元组不能完全相同-每一分量必须是不可再分的数据" class="headerlink" title="基本概念：* 关系、域、n目关系、元组、属性* 码  * 侯选码：某一属性组，唯一标识了一个元组，并且具有最小性  * 主码：若有多个候选码，选其中之一* 主属性与非主属性* 关系模式：R(U, D, dom, F)#### 2.1.2 关系模型的完整性约束* 实体完整性：主码不可为空* 参照完整性：如果关系R的主码 $F_k$ 与关系S的主码 $P_k$ 相对应，则R中的每一个元组的 $F_k$ 值或者等于S中的某个元组的 $P_k$ 值，或者为空。* 用户定义完整性#### 2.1.3 关系的性质* 列是同质的* 不同的列可出自同一域，每列必须有不同的属性名* 列的顺序无关紧要* 行的顺序无关紧要* 任意两个元组不能完全相同* 每一分量必须是不可再分的数据"></a><strong>基本概念</strong>：<br>* 关系、域、n目关系、元组、属性<br>* 码<br>  * 侯选码：某一属性组，唯一标识了一个元组，并且具有最小性<br>  * 主码：若有多个候选码，选其中之一<br>* 主属性与非主属性<br>* 关系模式：R(U, D, dom, F)<br>#### 2.1.2 关系模型的完整性约束<br>* 实体完整性：主码不可为空<br>* 参照完整性：如果关系R的主码 $F_k$ 与关系S的主码 $P_k$ 相对应，则R中的每一个元组的 $F_k$ 值或者等于S中的某个元组的 $P_k$ 值，或者为空。<br>* 用户定义完整性<br>#### 2.1.3 关系的性质<br>* 列是同质的<br>* 不同的列可出自同一域，每列必须有不同的属性名<br>* 列的顺序无关紧要<br>* 行的顺序无关紧要<br>* 任意两个元组不能完全相同<br>* 每一分量必须是不可再分的数据</h2><h2 id="第三章-SQL"><a href="#第三章-SQL" class="headerlink" title="第三章 SQL"></a>第三章 SQL</h2><h3 id="3-1-关系数据语言的分类及特点"><a href="#3-1-关系数据语言的分类及特点" class="headerlink" title="3.1 关系数据语言的分类及特点"></a>3.1 关系数据语言的分类及特点</h3><p>关系数据语言的核心是查询，所以又称为查询语言，关系运算的分类也决定了关系语言的分类。<br><strong>特点</strong>：</p>
<ul>
<li>一体化</li>
<li>非过程化</li>
<li>面向集合的存取方式</li>
<li>既可独立使用又可与主语言嵌套使用。</li>
</ul>
<h3 id="3-2-SQL数据查询功能"><a href="#3-2-SQL数据查询功能" class="headerlink" title="3.2 SQL数据查询功能"></a>3.2 SQL数据查询功能</h3><hr>
<h2 id="第四章-数据库保护"><a href="#第四章-数据库保护" class="headerlink" title="第四章 数据库保护"></a>第四章 数据库保护</h2><h3 id="4-1-数据安全性保护"><a href="#4-1-数据安全性保护" class="headerlink" title="4.1 数据安全性保护"></a>4.1 数据安全性保护</h3><h4 id="4-1-1-数据库安全性的含义"><a href="#4-1-1-数据库安全性的含义" class="headerlink" title="4.1.1 数据库安全性的含义"></a>4.1.1 数据库安全性的含义</h4><p><strong>定义</strong>：是指保护数据库以防止不合法的使用所造成的数据泄露、更改和破坏。包括以下两方面的含义：</p>
<ul>
<li>向授权用户提供可靠的信息服务</li>
<li>拒绝对数据的非授权存取访问请求。保证数据的可用性、完整性和一致性，进而保护数据库所有者和使用者的合法权益。</li>
</ul>
<h4 id="4-1-2-数据库系统安全性控制的手段或机制："><a href="#4-1-2-数据库系统安全性控制的手段或机制：" class="headerlink" title="4.1.2 数据库系统安全性控制的手段或机制："></a>4.1.2 数据库系统安全性控制的手段或机制：</h4><ul>
<li>用户标识与认证：标识是指系统采用一定的方式标识其用户或应用程序的名字或身份；认证是指系统在用户或应用程序登录时判断其是否为合法的授权用户。</li>
<li>访问控制（存取控制）<ul>
<li>用户权限定义：将用户权限记录到数据字典中，形成安全规则或授权规则</li>
<li>合法权限检查：当用户发出数据库操作请求后，DBMS根据数据字典中的安全规则检查用户权限是否合法</li>
</ul>
</li>
<li>加密技术：将原始数据（明文）变换为不可识别的格式（密文），从而使不知道解密算法的人无法获知数据的内容。</li>
<li>审计：把用户对数据库的所有操作都自动记录下来放入审计日志中。</li>
<li>视图机制：为不同的用户定义不同的视图，可以将用户对数据的访问限制在一定的范围内。</li>
</ul>
<h4 id="4-1-3-数据存取控制方法基本概念："><a href="#4-1-3-数据存取控制方法基本概念：" class="headerlink" title="4.1.3 数据存取控制方法基本概念："></a>4.1.3 数据存取控制方法基本概念：</h4><p><strong>自主存取控制</strong>：用户对于不同的数据对象拥有不同的存取权限，不同的用户对同一对象也有不同的权限，<strong>而且用户还可以将其拥有的权限转授给其他用户</strong>。<br><strong>强制存取控制</strong>：每一个数据对象被标以一定的密级，每一个用户也被授予某一级别的许可证。对于任一个对象，<strong>只有具有合法许可证的用户才可以存取</strong>。</p>
<h4 id="4-1-4-SQL存取控制"><a href="#4-1-4-SQL存取控制" class="headerlink" title="4.1.4 SQL存取控制"></a>4.1.4 SQL存取控制</h4><p><strong>用户级权限</strong>：为每个用户授予的特定权限，是对用户使用整个数据库权限的限定。<br><strong>关系级权限</strong>：与关系或视图有关的权限<br><strong>了解GRANT、REVOKE的用法</strong></p>
<h3 id="4-2-数据完整性保护"><a href="#4-2-数据完整性保护" class="headerlink" title="4.2 数据完整性保护"></a>4.2 数据完整性保护</h3><h4 id="4-2-1-数据库完整性的含义"><a href="#4-2-1-数据库完整性的含义" class="headerlink" title="4.2.1 数据库完整性的含义"></a>4.2.1 数据库完整性的含义</h4><p><strong>定义</strong>：数据完整性是指数据的正确性和相容性</p>
<ul>
<li>正确性：是指数据应具有合法的类型，并在有效取值范围之内</li>
<li>相容性：是指表示同一个事实的两个数据应该相同</li>
</ul>
<h4 id="4-2-2-完整性约束条件的分类"><a href="#4-2-2-完整性约束条件的分类" class="headerlink" title="4.2.2 完整性约束条件的分类"></a>4.2.2 完整性约束条件的分类</h4><ul>
<li>静态（列、元组、关系）</li>
<li>动态（列、元组、关系）</li>
</ul>
<h4 id="4-2-3-完整性控制功能构成"><a href="#4-2-3-完整性控制功能构成" class="headerlink" title="4.2.3 完整性控制功能构成"></a>4.2.3 完整性控制功能构成</h4><ul>
<li>定义功能</li>
<li>检查功能</li>
<li>违约响应</li>
</ul>
<h4 id="4-2-4-SQL完整性支持功能"><a href="#4-2-4-SQL完整性支持功能" class="headerlink" title="4.2.4 SQL完整性支持功能"></a>4.2.4 SQL完整性支持功能</h4><ul>
<li>CREATE TABLE</li>
<li>ASSERTION</li>
<li>触发器</li>
</ul>
<hr>
<h2 id="第五章-关系数据理论"><a href="#第五章-关系数据理论" class="headerlink" title="第五章 关系数据理论"></a>第五章 关系数据理论</h2><h3 id="5-1-函数依赖"><a href="#5-1-函数依赖" class="headerlink" title="5.1 函数依赖"></a>5.1 函数依赖</h3><h4 id="5-1-1-基本概念"><a href="#5-1-1-基本概念" class="headerlink" title="5.1.1 基本概念"></a>5.1.1 基本概念</h4><p><strong>定义</strong>：函数依赖 X -&gt; Y 可定义为对于X的每个具体值，Y有唯一的值与之对应。<br><strong>完全函数依赖</strong><br><strong>部分函数依赖</strong><br><strong>传递函数依赖</strong></p>
<h4 id="5-1-2-属性集闭包的概念及求法"><a href="#5-1-2-属性集闭包的概念及求法" class="headerlink" title="5.1.2 属性集闭包的概念及求法"></a>5.1.2 属性集闭包的概念及求法</h4><h4 id="5-1-3-候选码求法"><a href="#5-1-3-候选码求法" class="headerlink" title="5.1.3 候选码求法"></a>5.1.3 候选码求法</h4><h4 id="5-1-4-最小依赖集"><a href="#5-1-4-最小依赖集" class="headerlink" title="5.1.4 最小依赖集"></a>5.1.4 最小依赖集</h4><h4 id="5-1-5-Armstrong公理系统"><a href="#5-1-5-Armstrong公理系统" class="headerlink" title="5.1.5 Armstrong公理系统"></a>5.1.5 Armstrong公理系统</h4><ul>
<li>自反律</li>
<li>增广律</li>
<li>传递律</li>
</ul>
<h3 id="5-2-范式"><a href="#5-2-范式" class="headerlink" title="5.2 范式"></a>5.2 范式</h3><h4 id="5-2-1-范式等级判定"><a href="#5-2-1-范式等级判定" class="headerlink" title="5.2.1 范式等级判定"></a>5.2.1 范式等级判定</h4><p><strong>1NF</strong>：没有“表中套表”<br><strong>2NF</strong>：每个<strong>非主属性</strong>完全依赖于码<br><strong>3NF</strong>：非主属性对码不能有传递依赖<br><strong>BCNF</strong>：每个函数依赖，左部必须含有码</p>
<ul>
<li>所有非主属性都完全依赖于码</li>
<li>所有主属性都完全依赖于每个不包含它的候选码</li>
<li>没有任何属性完全依赖于非码的任何一组属性</li>
</ul>
<h3 id="5-3-模式分解算法"><a href="#5-3-模式分解算法" class="headerlink" title="5.3 模式分解算法"></a>5.3 模式分解算法</h3><h4 id="5-3-1-无损分解的判定算法"><a href="#5-3-1-无损分解的判定算法" class="headerlink" title="5.3.1 无损分解的判定算法"></a>5.3.1 无损分解的判定算法</h4><ol>
<li>画表（步骤见ppt）</li>
<li>定理：R1，R2的共同属性至少构成R1，R2二者之一的候选码。</li>
</ol>
<h4 id="5-3-2-分解的保持函数依赖性判定算法"><a href="#5-3-2-分解的保持函数依赖性判定算法" class="headerlink" title="5.3.2 分解的保持函数依赖性判定算法"></a>5.3.2 分解的保持函数依赖性判定算法</h4><p>R中的每个函数依赖都能够从R1…Rn函数依赖的并集当中逻辑导出</p>
<h4 id="5-3-3-模式分解的原则"><a href="#5-3-3-模式分解的原则" class="headerlink" title="5.3.3 模式分解的原则"></a>5.3.3 模式分解的原则</h4><ul>
<li>具有无损连接性</li>
<li>保持函数依赖</li>
</ul>
<h4 id="5-3-4-模式分解的算法：达到3NF且满足两条分解算法"><a href="#5-3-4-模式分解的算法：达到3NF且满足两条分解算法" class="headerlink" title="5.3.4 模式分解的算法：达到3NF且满足两条分解算法"></a>5.3.4 模式分解的算法：达到3NF且满足两条分解算法</h4><p>步骤见ppt</p>
<h4 id="5-3-5-候选码的快速求法"><a href="#5-3-5-候选码的快速求法" class="headerlink" title="5.3.5 候选码的快速求法"></a>5.3.5 候选码的快速求法</h4><p>先把所有属性分成四类：L类、R类、N类、LR类<br>求N、L类的属性集的闭包，看是否等于U</p>
<hr>
<h2 id="第六章-数据库设计"><a href="#第六章-数据库设计" class="headerlink" title="第六章 数据库设计"></a>第六章 数据库设计</h2><h3 id="6-1-数据库规范设计法"><a href="#6-1-数据库规范设计法" class="headerlink" title="6.1 数据库规范设计法"></a>6.1 数据库规范设计法</h3><p><strong>阶段</strong>：</p>
<ul>
<li>需求分析：对应用环境进行详细调查，收集支持系统目标的基础数据及其处理</li>
<li><strong>数据库概念结构设计</strong>：通过对用户需求进行综合、归纳与抽象，形成独立于数据库逻辑结构与具体DBMS的概念模型，可以用E-R图表示</li>
<li>数据库逻辑结构设计：将概念结构转换为某个特定的DBMS所支持的数据模型，并进行优化。再将得到的逻辑结构转换成特定的DBMS能处理的模式、子模式</li>
<li>数据库物理结构设计：设计数据库在物理设备上的存储结构和存取方法。一般分为两步:一是确定数据库的内模式;二是对物理结构进行时间与空间效率的评价;</li>
<li>数据库实施：建立数据库的过程。用DBMS的DDL描述三级模式，并调试产生目标模式。开发应用程序，组织数据入库并试运行;</li>
<li>数据库运行和维护：在数据库正式运行后，由DBA执行对数据库经常性的维护工作，包括数据库转储与恢复、数据库控制、数据库性能监控、数据库的重组与重构</li>
</ul>
<h3 id="6-2-概念结构设计"><a href="#6-2-概念结构设计" class="headerlink" title="6.2 概念结构设计"></a>6.2 概念结构设计</h3><p>画E-R图<br><strong>局部ER图合并中的冲突</strong>：</p>
<ul>
<li>属性冲突：属性的类型、取值范围、取值集合不同</li>
<li>命名冲突：同名异义、异名同义</li>
<li>结构冲突：同一对象在不同应用中有不同抽象。如在一应用中为实体、在另一应用中为属性</li>
</ul>
<p>冗余联系没必要在合并时解决</p>
<h3 id="6-3-逻辑结构设计"><a href="#6-3-逻辑结构设计" class="headerlink" title="6.3 逻辑结构设计"></a>6.3 逻辑结构设计</h3><h4 id="6-3-1-E-R图向关系模型的转换规则"><a href="#6-3-1-E-R图向关系模型的转换规则" class="headerlink" title="6.3.1 E-R图向关系模型的转换规则"></a>6.3.1 E-R图向关系模型的转换规则</h4><ul>
<li>一个实体型转换为一个关系模式</li>
<li>一个联系转换为一个关系模式<ul>
<li>1:1联系：每个关系的码均是该关系的候选码，可以合并到任意一端实体，把联系的属性加进实体里，另一端实体的主码作为外码</li>
<li>1:n联系：该关系的码是n端实体的码，合并到n端实体，把联系的属性加进实体里，1端实体的码作为n端实体的外码</li>
<li>n:m联系：该关系的码是逐实体码的组合</li>
</ul>
</li>
<li>三个或以上实体间的多元联系，转换为一个关系模式。</li>
<li>具有相同码的关系可以合并</li>
</ul>
<h4 id="6-3-2-关系模型的优化"><a href="#6-3-2-关系模型的优化" class="headerlink" title="6.3.2 关系模型的优化"></a>6.3.2 关系模型的优化</h4><p><strong>水平分解</strong>：把关系的<strong>元组</strong>分为若干子集合</p>
<ul>
<li>80&#x2F;20原则：把经常用的一部分数据提取出来作为一个关系</li>
<li>数据分片：如果关系R上具有n个事务而且多数事务存取的数据不相交，则把R分解为少于或等于n个子关系。</li>
</ul>
<p><strong>垂直分解</strong>：把关系的<strong>属性</strong>分解为若干子集合</p>
<ul>
<li>原则：经常在一起使用的属性从R中分解出来形成一个子关系模式</li>
<li>必须确保无损连接和保持函数依赖</li>
</ul>
<h3 id="6-4-常用存取方法基本概念及选择原则"><a href="#6-4-常用存取方法基本概念及选择原则" class="headerlink" title="6.4 常用存取方法基本概念及选择原则"></a>6.4 常用存取方法基本概念及选择原则</h3><p><strong>常用存取方法</strong>：</p>
<ul>
<li>索引方法：<ul>
<li>B树索引</li>
<li>B+树索引</li>
<li>HASH索引</li>
</ul>
</li>
<li>聚集方法</li>
<li>HASH方法</li>
</ul>
<hr>
<h2 id="第七章-存储管理与索引"><a href="#第七章-存储管理与索引" class="headerlink" title="第七章 存储管理与索引"></a>第七章 存储管理与索引</h2><h3 id="7-1-数据的存储结构-物理结构"><a href="#7-1-数据的存储结构-物理结构" class="headerlink" title="7.1 数据的存储结构&#x2F;物理结构"></a>7.1 数据的存储结构&#x2F;物理结构</h3><h4 id="7-1-1-DBMS存储管理的目标"><a href="#7-1-1-DBMS存储管理的目标" class="headerlink" title="7.1.1 DBMS存储管理的目标"></a>7.1.1 DBMS存储管理的目标</h4><h4 id="7-1-2-文件中记录的几种组织方式的含义"><a href="#7-1-2-文件中记录的几种组织方式的含义" class="headerlink" title="7.1.2 文件中记录的几种组织方式的含义"></a>7.1.2 文件中记录的几种组织方式的含义</h4><p><strong>堆</strong>：记录可以存放在文件空间中的任何位置<br><strong>顺序</strong>：基于每个记录的搜索码值顺序排列<br><strong>索引</strong>：按某种顺序有序存储<br><strong>散列</strong> 在搜索码上的hash函数，计算出记录在文件中存放的块<br><strong>聚集</strong>：将有联系的记录存储在同一个块上，以最小化I&#x2F;O次数</p>
<h4 id="7-1-3-页-块的分槽结构"><a href="#7-1-3-页-块的分槽结构" class="headerlink" title="7.1.3 页&#x2F;块的分槽结构"></a>7.1.3 页&#x2F;块的分槽结构</h4><h3 id="7-2-缓冲区管理"><a href="#7-2-缓冲区管理" class="headerlink" title="7.2 缓冲区管理"></a>7.2 缓冲区管理</h3><p>缓冲区：是主存中可以存储磁盘块副本的区域<br>缓冲区管理器：负责缓存空间分配，内外存交换<br>管理目标：最小化磁盘和主存间传输存储块的数量，即最小化磁盘存取次数，实现手段是在主存中保持尽量多的块。</p>
<h3 id="7-3-索引"><a href="#7-3-索引" class="headerlink" title="7.3 索引"></a>7.3 索引</h3><h4 id="7-3-1-基本概念"><a href="#7-3-1-基本概念" class="headerlink" title="7.3.1 基本概念"></a>7.3.1 基本概念</h4><ul>
<li>索引文件构成：索引记录&#x2F;索引项，包括两个域<ul>
<li>索引域：存储数据文件中一个或一组域（属性）</li>
<li>指针：指向索引域值为K的记录所在磁盘块的地址</li>
</ul>
</li>
<li>索引将表中的部分属性进行组织或排序，使得DBMS的执行引擎利用这些属性能够快速有效地进行表的访问</li>
</ul>
<h4 id="7-3-2-索引的分类"><a href="#7-3-2-索引的分类" class="headerlink" title="7.3.2 索引的分类"></a>7.3.2 索引的分类</h4><ol>
<li>两种基本类型<ul>
<li>排序索引</li>
<li>哈希索引</li>
</ul>
</li>
<li>聚集索引与非聚集索引<ul>
<li>聚集索引：索引域的排列顺序与记录在文件中的排列顺序一致，也称为主索引</li>
<li>非聚集索引：索引项排列的顺序与文件中的排列顺序不同，也称为辅助索引</li>
</ul>
</li>
<li>稠密索引与稀疏索引<ul>
<li>稠密索引：对于文件中的每个搜索码值都有一个索引项（<strong>非聚集索引都是稠密索引</strong>）</li>
<li>稀疏索引：只有部分索引域有索引记录</li>
</ul>
</li>
</ol>
<h4 id="7-3-3-B树、B-树的原理"><a href="#7-3-3-B树、B-树的原理" class="headerlink" title="7.3.3 B树、B+树的原理"></a>7.3.3 B树、B+树的原理</h4><p>不同点：</p>
<ul>
<li>B树：关键字散布在各层</li>
<li>B+树：树中所有关键字都按递增次序从左到右安排在叶节点上，并且连接起来。可以同时进行随机查找和顺序查找</li>
</ul>
<p>相同点：</p>
<ul>
<li>限制每个节点放置关键字与指针的最大最小个数</li>
<li>所有叶节点都在同一层</li>
</ul>
<h4 id="7-3-4-Hash索引的原理"><a href="#7-3-4-Hash索引的原理" class="headerlink" title="7.3.4 Hash索引的原理"></a>7.3.4 Hash索引的原理</h4><p>基于哈希表实现，分为静态哈希和动态哈希</p>
<hr>
<h2 id="第八章-查询处理与查询优化"><a href="#第八章-查询处理与查询优化" class="headerlink" title="第八章 查询处理与查询优化"></a>第八章 查询处理与查询优化</h2><h3 id="8-1-查询处理的步骤"><a href="#8-1-查询处理的步骤" class="headerlink" title="8.1 查询处理的步骤"></a>8.1 查询处理的步骤</h3><ol>
<li>查询分析<ul>
<li>词法分析</li>
<li>SQL语法检查和语法分析</li>
</ul>
</li>
<li>查询检查<ul>
<li>语义检查</li>
<li>存取权限检查</li>
<li>SQL语句转换为关系代数表达式</li>
</ul>
</li>
<li>查询优化<ul>
<li>选择一个高效执行的查询处理</li>
<li>生成查询计划</li>
</ul>
</li>
<li>查询执行<ul>
<li>生成查询计划的代码</li>
<li>代码执行</li>
</ul>
</li>
</ol>
<h3 id="8-2-主要查询操作的实现算法"><a href="#8-2-主要查询操作的实现算法" class="headerlink" title="8.2 主要查询操作的实现算法"></a>8.2 主要查询操作的实现算法</h3><ul>
<li><strong>选择</strong>：<ul>
<li>全表扫描法</li>
<li>索引扫描法</li>
</ul>
</li>
<li><strong>连接</strong>：<ul>
<li>嵌套循环法：两个连接的表，第一个表为外循环，第二个表为内循环</li>
<li>索引连接法：第二个表按照连接属性建立索引，取第一个表元组的连接属性与第二个表元组的连接属性比较</li>
<li>排序–合并法：两个表都按照连接属性排序，取第一个表元组的连接属性与第二个表元组的连接属性比较</li>
<li>Hash join法：连接属性作为hash码，用同一个hash函数把两个连接表的元组散列到同一个hash文件中</li>
</ul>
</li>
</ul>
<h3 id="8-3-查询优化的目标"><a href="#8-3-查询优化的目标" class="headerlink" title="8.3 查询优化的目标"></a>8.3 查询优化的目标</h3><p>选择一个高效执行的查询处理策略，使得查询代价 最小，即访问磁盘的块数最少</p>
<h3 id="8-4-代数优化"><a href="#8-4-代数优化" class="headerlink" title="8.4 代数优化"></a>8.4 代数优化</h3><ul>
<li><strong>基本概念</strong>：通过对关系代数表达式的等价变换来提高查询效率</li>
<li><strong>等价变换规则</strong>：见ppt</li>
<li><strong>一般准则</strong>：<ul>
<li><strong>选择运算尽早执行</strong></li>
<li><strong>投影运算尽早执行</strong></li>
<li>把投影运算和选择运算同时进行，把投影同其前或其后的双目运算结合起来</li>
<li>把某些选择同在它前面要执行的笛卡尔积结合起来成为一个新的运算</li>
<li>找出公共子表达式，把结果写入中间文件</li>
</ul>
</li>
<li><strong>优化算法</strong></li>
</ul>
<h3 id="8-5-物理优化"><a href="#8-5-物理优化" class="headerlink" title="8.5 物理优化"></a>8.5 物理优化</h3><p><strong>含义</strong>：选择高效合理的操作算法或存取路径，得到优化的查询算法<br><strong>常用方法</strong>：</p>
<ul>
<li>基于规则的启发式优化算法：<ul>
<li>选择：小关系–全表顺序扫描；大关系：索引扫描&#x2F;全表顺序扫描</li>
<li>连接：<ul>
<li>如果两个表都已经按照连接属性排序—-排序合并法</li>
<li>如果一个表在连接属性上有索引—-索引扫描法</li>
<li>如果连接属性上未排序且未建索引，且其中一个表较小—-Hash Join法</li>
<li>实在没辙—-嵌套循环法，小表作为外循环</li>
</ul>
</li>
</ul>
</li>
<li>基于代价估算的优化方法：计算各种操作算法的执行代价，选择具有最小代价的执行计划。</li>
<li>两者结合的优化方法</li>
</ul>
<hr>
<h2 id="第九章-事务处理技术"><a href="#第九章-事务处理技术" class="headerlink" title="第九章 事务处理技术"></a>第九章 事务处理技术</h2><h3 id="9-1-事务"><a href="#9-1-事务" class="headerlink" title="9.1 事务"></a>9.1 事务</h3><ul>
<li><strong>概念</strong>：是用户定义的数据库操作序列，这些操作要么都做，要么都不做，是一个不可分割的工作单位。</li>
<li><strong>特性（ACID）</strong>：<ul>
<li>原子性（<strong>A</strong>tomicity）：事务中包括的所有操作要么都做，要么都不做</li>
<li>一致性（<strong>C</strong>onsistency）：事务执行的结果必须是使数据库从一个一致性状态，变到另一个一致性状态</li>
<li>隔离性（<strong>I</strong>solation）：一个事物的执行不能被其他事务干扰</li>
<li>持久性（<strong>D</strong>urability）：一个事务一旦提交，它对数据库的影响必须是永久的</li>
</ul>
</li>
</ul>
<h3 id="9-2-数据库恢复"><a href="#9-2-数据库恢复" class="headerlink" title="9.2 数据库恢复"></a>9.2 数据库恢复</h3><h4 id="9-2-1-数据库恢复的基本原理与技术"><a href="#9-2-1-数据库恢复的基本原理与技术" class="headerlink" title="9.2.1 数据库恢复的基本原理与技术"></a>9.2.1 数据库恢复的基本原理与技术</h4><ul>
<li><strong>定义</strong>：数据库管理系统必须具有把数据库从错误状态恢复到某一已知正确状态的功能，这就是数据库的恢复。</li>
<li><strong>数据库恢复子系统的意义</strong>：<ul>
<li>保证事务的原子性</li>
<li>当系统发生故障以后，数据库能够恢复到正常状态</li>
</ul>
</li>
<li><strong>数据转储</strong>：<ul>
<li>定义：定期将整个数据库复制到浏览器磁带或另一个磁盘上保存起来的过程。这些备用的数据文本为后备副本或后援副本。</li>
<li>两种转储状态<ul>
<li>静态转储：系统中无事务运行时进行，转储过程中不允许对数据库进行任何存取、修改</li>
<li>动态转储：转储期间允许对数据库进行存取或修改</li>
</ul>
</li>
<li>两种转储方式<ul>
<li>海量转储：每次全部转储</li>
<li>增量转储：只转储更新过的数据</li>
</ul>
</li>
</ul>
</li>
<li><strong>日志文件</strong>：<ul>
<li>定义：用来记录事务对数据库更新操作的文件</li>
<li>两种格式<ul>
<li>以记录为单位</li>
<li>以数据块为单位</li>
</ul>
</li>
<li>作用：<ul>
<li>事务故障和系统故障必须使用日志文件</li>
<li>动态转储中，必须用日志文件，后备副本 + 日志文件合起来才能有效地恢复数据库</li>
<li>静态转储中，用日志文件恢复转储结束时刻到故障点间的事务</li>
</ul>
</li>
<li>写入规则：先写日志文件，后写数据库</li>
</ul>
</li>
</ul>
<h4 id="9-2-2-故障的种类"><a href="#9-2-2-故障的种类" class="headerlink" title="9.2.2 故障的种类"></a>9.2.2 故障的种类</h4><ul>
<li>事务内部的故障（可预期的、不可预期的）</li>
<li>系统故障</li>
<li>介质故障</li>
<li>计算机病毒</li>
</ul>
<h4 id="9-2-3-恢复策略"><a href="#9-2-3-恢复策略" class="headerlink" title="9.2.3 恢复策略"></a>9.2.3 恢复策略</h4><ul>
<li>事务故障：Undo（不影响其他事务的情况下，强行回滚）</li>
<li>系统故障：Undo + Redo（<strong>正向</strong>扫描日志文件，做完的Redo，没做完的Undo）</li>
<li>介质故障：装入最新的数据库后备副本，是数据库恢复到最近一次转储时的一致状态。</li>
<li>具有检查点的恢复技术：检查点技术可以改善效率，使得在检查点之前提交的事务，在数据库恢复处理时不必重做。故障之前做完的：Redo，故障发生还没做完的：Undo</li>
</ul>
<h3 id="9-3-并发控制"><a href="#9-3-并发控制" class="headerlink" title="9.3 并发控制"></a>9.3 并发控制</h3><p><strong>可能导致的问题</strong>：破坏一致性<br><strong>基本思想</strong>：合理调度并发事务<br><strong>基本手段</strong>：封锁机制——事务T在对某个数据对象操作之前，先向系统发出请求，对其加锁，从而对该数据对象有了一定的控制权<br><strong>锁的类型</strong>：排它锁（X），共享锁（S）<br><strong>三种封锁协议</strong>：</p>
<ul>
<li>一级封锁协议：修改数据之前对事务加 X 锁，结束释放。可以防止丢失修改</li>
<li>二级封锁协议：一级 + 读数据之前加 S 锁，读完后释放 S 锁。可以防止读脏数据</li>
<li>三级封锁协议：一级 + 读数据之前加 S 锁，直到结束才释放。可以防止“不可重复读”</li>
</ul>
<p><strong>可串行性概念</strong>：多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行执行它们时的结果相同，我们称这种调度策略为可串行化调度。<br><strong>两段锁协议</strong>：</p>
<ol>
<li>在对任何数据进行读写操作之前，事务首先要获得对该数据的封锁</li>
<li>在释放一个锁之后，事务不再获得任何其他封锁</li>
</ol>
<h2 id="死锁：-预防：-一次封锁法：一次将所有要使用的数据全部加锁-顺序封锁法：预先对数据对象规定一个封锁顺序-检测：-超时法-等待图法-解除：选择一个处理死锁代价最小的事务，将其撤销-9-4-多粒度封锁与意向锁多粒度封锁协议意向锁：-含义：该结点的下层结点正在被加锁-对任意节点加锁时，必须先对其上级节点加意向锁-好处：在对象加锁时，不再检查下级节点的封锁，只需检查对象和它的上级节点。"><a href="#死锁：-预防：-一次封锁法：一次将所有要使用的数据全部加锁-顺序封锁法：预先对数据对象规定一个封锁顺序-检测：-超时法-等待图法-解除：选择一个处理死锁代价最小的事务，将其撤销-9-4-多粒度封锁与意向锁多粒度封锁协议意向锁：-含义：该结点的下层结点正在被加锁-对任意节点加锁时，必须先对其上级节点加意向锁-好处：在对象加锁时，不再检查下级节点的封锁，只需检查对象和它的上级节点。" class="headerlink" title="死锁：* 预防：  * 一次封锁法：一次将所有要使用的数据全部加锁  * 顺序封锁法：预先对数据对象规定一个封锁顺序* 检测：  * 超时法  * 等待图法* 解除：选择一个处理死锁代价最小的事务，将其撤销### 9.4 多粒度封锁与意向锁多粒度封锁协议意向锁：* 含义：该结点的下层结点正在被加锁* 对任意节点加锁时，必须先对其上级节点加意向锁* 好处：在对象加锁时，不再检查下级节点的封锁，只需检查对象和它的上级节点。
  "></a><strong>死锁</strong>：<br>* 预防：<br>  * 一次封锁法：一次将所有要使用的数据全部加锁<br>  * 顺序封锁法：预先对数据对象规定一个封锁顺序<br>* 检测：<br>  * 超时法<br>  * 等待图法<br>* 解除：选择一个处理死锁代价最小的事务，将其撤销<br>### 9.4 多粒度封锁与意向锁<br><strong>多粒度封锁协议</strong><br><strong>意向锁</strong>：<br>* 含义：该结点的下层结点正在被加锁<br>* 对任意节点加锁时，必须先对其上级节点加意向锁<br>* 好处：在对象加锁时，不再检查下级节点的封锁，只需检查对象和它的上级节点。
  </h2><h2 id="第十章-数据库技术新发展"><a href="#第十章-数据库技术新发展" class="headerlink" title="第十章 数据库技术新发展"></a>第十章 数据库技术新发展</h2><h3 id="10-1-分布式数据库的定义与特点"><a href="#10-1-分布式数据库的定义与特点" class="headerlink" title="10.1 分布式数据库的定义与特点"></a>10.1 分布式数据库的定义与特点</h3><p><strong>定义</strong>：分布式数据库是由一组分布在计算机网络的不同结点上的数据组成，每个结点具有独立处理的能力(称为场地自治)，可以执行局部应用，同时每个结点也能通过网络通信支持全局应用。<br><strong>特点</strong>：</p>
<ul>
<li>数据独立性</li>
<li>集中与自治相结合的控制结构</li>
<li>适当增加数据冗余</li>
<li>全局的一致性、可串行性、可恢复性</li>
</ul>
<h3 id="10-2-分布式数据库系统的模式结构"><a href="#10-2-分布式数据库系统的模式结构" class="headerlink" title="10.2 分布式数据库系统的模式结构"></a>10.2 分布式数据库系统的模式结构</h3><ol>
<li>全局外模式及全局外模式&#x2F;全局概念模式映象</li>
<li>全局概念模式</li>
<li>分片模式及全局概念模式&#x2F;分片模式映象</li>
<li>分布模式及分片模式&#x2F;分布模式映象</li>
<li>分布模式&#x2F;局部数据库概念模式映象</li>
</ol>
<h3 id="10-3-数据分片方式"><a href="#10-3-数据分片方式" class="headerlink" title="10.3 数据分片方式"></a>10.3 数据分片方式</h3><ul>
<li>较基本：水平分片、垂直分片</li>
<li>较复杂：混合分片、导出分片</li>
</ul>
<h3 id="10-4-分布透明性的概念"><a href="#10-4-分布透明性的概念" class="headerlink" title="10.4 分布透明性的概念"></a>10.4 分布透明性的概念</h3><ul>
<li>分片透明性：用户或应用程序只对全局关系进行操作而不必考虑关系的分片。它是分布透明性的最高层次。<strong>依靠全局概念模式&#x2F;分片模式实现</strong></li>
<li>位置透明性：用户或应用程序不必了解片段的存储场地也不必关心各数据副本的一致性。</li>
<li>局部数据模型透明性：用户或应用程序不必了解局部场地上使用的是哪种数据模型。模型的转换以及查询语言等的转换均由分布模式&#x2F;局部概念模式(映象4)完成。</li>
</ul>
<h3 id="10-5-分布式查询处理和优化"><a href="#10-5-分布式查询处理和优化" class="headerlink" title="10.5 分布式查询处理和优化"></a>10.5 分布式查询处理和优化</h3><p>目标：</p>
<ul>
<li>查询：执行的开销I&#x2F;O代价 + CPU代价 + 通信代价</li>
</ul>
<p><strong>全局查询是分布式数据库查询优化的主要对象</strong></p>
<p>连接查询的优化：半连接</p>
<h3 id="10-6-分布式事务处理"><a href="#10-6-分布式事务处理" class="headerlink" title="10.6 分布式事务处理"></a>10.6 分布式事务处理</h3><p><strong>分布事务的原子性</strong>：组成该事务的所有子事务要么全部提交，要么全部回滚。<br><strong>两段提交协议</strong>：两段提交协议把一个分布事务的所有局部事务管理分为两类，协调者和参与者。</p>
<ul>
<li>第一阶段：协调者征求意见做决定</li>
<li>第二阶段：参与者执行决定</li>
</ul>
]]></content>
      <categories>
        <category>专业课</category>
      </categories>
      <tags>
        <tag>知识点总结</tag>
        <tag>Database</tag>
      </tags>
  </entry>
</search>
